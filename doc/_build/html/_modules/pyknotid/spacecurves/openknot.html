

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyknotid.spacecurves.openknot &mdash; pyknotid 0.5.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=c3dca1ed"></script>
      <script src="../../../_static/doctools.js?v=888ff710"></script>
      <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            pyknotid
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/spacecurves/index.html">Space curve analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html">Invariants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.alexander"><code class="docutils literal notranslate"><span class="pre">alexander()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.alexander_cypari"><code class="docutils literal notranslate"><span class="pre">alexander_cypari()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.alexander_mathematica"><code class="docutils literal notranslate"><span class="pre">alexander_mathematica()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.alexander_maxima"><code class="docutils literal notranslate"><span class="pre">alexander_maxima()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.arnold_2St_2Jminus"><code class="docutils literal notranslate"><span class="pre">arnold_2St_2Jminus()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.arnold_2St_2Jplus"><code class="docutils literal notranslate"><span class="pre">arnold_2St_2Jplus()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.contract_points"><code class="docutils literal notranslate"><span class="pre">contract_points()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.hyperbolic_volume"><code class="docutils literal notranslate"><span class="pre">hyperbolic_volume()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.jones_mathematica"><code class="docutils literal notranslate"><span class="pre">jones_mathematica()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.second_order_writhe"><code class="docutils literal notranslate"><span class="pre">second_order_writhe()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.self_linking"><code class="docutils literal notranslate"><span class="pre">self_linking()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.vassiliev_degree_2"><code class="docutils literal notranslate"><span class="pre">vassiliev_degree_2()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.vassiliev_degree_3"><code class="docutils literal notranslate"><span class="pre">vassiliev_degree_3()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.virtual_vassiliev_degree_3"><code class="docutils literal notranslate"><span class="pre">virtual_vassiliev_degree_3()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/representations/index.html">Topological representations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/catalogue/index.html">Knot catalogue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html">Visualise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_line"><code class="docutils literal notranslate"><span class="pre">plot_line()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_projection"><code class="docutils literal notranslate"><span class="pre">plot_projection()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_shell_vispy"><code class="docutils literal notranslate"><span class="pre">plot_shell_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_sphere_lambert_sharp_vispy"><code class="docutils literal notranslate"><span class="pre">plot_sphere_lambert_sharp_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_sphere_lambert_vispy"><code class="docutils literal notranslate"><span class="pre">plot_sphere_lambert_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_sphere_mollweide_vispy"><code class="docutils literal notranslate"><span class="pre">plot_sphere_mollweide_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_sphere_shell_vispy"><code class="docutils literal notranslate"><span class="pre">plot_sphere_shell_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/about.html">About pyknotid</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pyknotid</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyknotid.spacecurves.openknot</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyknotid.spacecurves.openknot</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">OpenKnot</span>
<span class="sd">========</span>

<span class="sd">Class for working with open (linear) curves, that do not form closed</span>
<span class="sd">loops. :class:`OpenKnot` provides methods for visualising these curves</span>
<span class="sd">and analysing their topology via different kinds of closures.</span>

<span class="sd">API documentation</span>
<span class="sd">~~~~~~~~~~~~~~~~~</span>

<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sym</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves.spacecurve</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpaceCurve</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves.knot</span><span class="w"> </span><span class="kn">import</span> <span class="n">Knot</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves.rotation</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_rotation_angles</span><span class="p">,</span> <span class="n">rotate_to_top</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Counter</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.invariants</span><span class="w"> </span><span class="kn">import</span> <span class="n">alexander</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.representations.gausscode</span><span class="w"> </span><span class="kn">import</span> <span class="n">GaussCode</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.representations.representation</span><span class="w"> </span><span class="kn">import</span> <span class="n">Representation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.visualise</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_shell</span><span class="p">,</span> <span class="n">plot_sphere_shell_vispy</span>


<div class="viewcode-block" id="OpenKnot"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">OpenKnot</span><span class="p">(</span><span class="n">SpaceCurve</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Class for holding the vertices of a single line that is assumed to</span>
<span class="sd">    be an open curve. This class inherits from</span>
<span class="sd">    :class:`~pyknotid.spacecurves.spacecurve.SpaceCurve`, replacing any</span>
<span class="sd">    default arguments that assume closed curves, and providing methods</span>
<span class="sd">    for statistical analysis of knot invariants on projection and closure.</span>

<span class="sd">    All knot invariant methods return the results of a sampling over</span>
<span class="sd">    many projections of the knot, unless indicated otherwise.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OpenKnot</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_v2</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_v3</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@SpaceCurve</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OpenKnot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_alexanders</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">tangents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Knot</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">tangents</span><span class="p">(</span><span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="OpenKnot.closing_distance"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.closing_distance">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">closing_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the distance between the first and last points.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="OpenKnot.raw_crossings"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.raw_crossings">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">raw_crossings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;use_max_jump&#39;</span><span class="p">,</span>
                      <span class="n">virtual_closure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">recalculate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">try_cython</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calls :meth:`pyknotid.spacecurves.spacecurve.SpaceCurve.raw_crossings`,</span>
<span class="sd">        but without including the closing line between the last</span>
<span class="sd">        and first points (i.e. setting include_closure=False).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">virtual_closure</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">OpenKnot</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">raw_crossings</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                                                       <span class="n">include_closure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                       <span class="n">recalculate</span><span class="o">=</span><span class="n">recalculate</span><span class="p">,</span>
                                                       <span class="n">try_cython</span><span class="o">=</span><span class="n">try_cython</span><span class="p">)</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">OpenKnot</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">raw_crossings</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                                                 <span class="n">include_closure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                 <span class="n">recalculate</span><span class="o">=</span><span class="n">recalculate</span><span class="p">,</span>
                                                 <span class="n">try_cython</span><span class="o">=</span><span class="n">try_cython</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">closure_cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">|</span>
                                    <span class="p">((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">closure_cs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">cs</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">cs</span></div>
        

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crossings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&lt;OpenKnot with </span><span class="si">{}</span><span class="s1"> points, </span><span class="si">{}</span><span class="s1"> crossings&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_crossings</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;OpenKnot with </span><span class="si">{}</span><span class="s1"> points&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">closures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">num_closures</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">num_closures</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Representation</span><span class="p">,</span> <span class="n">quantity</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Representation has no invariant </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">quantity</span><span class="p">))</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">print_dist</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">3000.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;angs are&#39;</span><span class="p">,</span> <span class="n">angs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">print_dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vprint</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">i = </span><span class="si">{}</span><span class="s1"> / </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)),</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">Knot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="o">*</span><span class="n">angs</span><span class="p">))</span>
            <span class="n">k</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">raw_crossings</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">closure_cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">))</span> <span class="o">|</span>
                                        <span class="p">((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">)))</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">closure_cs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                    <span class="n">cs</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">gc</span> <span class="o">=</span> <span class="n">Representation</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)())</span>
        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="OpenKnot.arclength"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.arclength">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">arclength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Calls :meth:`pyknotid.spacecurves.spacecurve.SpaceCurve.arclength`,</span>
<span class="sd">        automatically *not* including the closure.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">OpenKnot</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">arclength</span><span class="p">(</span><span class="n">include_closure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="OpenKnot.smooth"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.smooth">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hanning&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Calls :meth:`pyknotid.spacecurves.spacecurve.SpaceCurve.smooth`,</span>
<span class="sd">        with the periodic argument automatically set to False.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OpenKnot</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">repeats</span><span class="o">=</span><span class="n">repeats</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="n">window_len</span><span class="p">,</span>
                                     <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">_plot_uniform_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Plots the projection of the knot at each of the given</span>
<span class="sd">        number of samples, approximately evenly distributed on</span>
<span class="sd">        the sphere.</span>

<span class="sd">        This function is really just for testing.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">number_of_samples</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="o">*</span><span class="n">angs</span><span class="p">))</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">plot_projection</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;rotation</span><span class="si">{:05d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<div class="viewcode-block" id="OpenKnot.plot_projections"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.plot_projections">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot_projections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Plots the projection of the knot at each of the given</span>
<span class="sd">        number of samples squared, rotated such that the sample</span>
<span class="sd">        direction is vertical.</span>

<span class="sd">        The output (and return) is a matplotlib plot with</span>
<span class="sd">        number_of_samples x number_of_samples axes.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">number_of_samples</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Got angles&#39;</span><span class="p">)</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="n">number_of_samples</span><span class="p">,</span>
                                 <span class="n">ncols</span><span class="o">=</span><span class="n">number_of_samples</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;got axes&#39;</span><span class="p">)</span>

        <span class="n">all_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">axes</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">row</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vprint</span><span class="p">(</span><span class="s1">&#39;i = </span><span class="si">{}</span><span class="s1"> / </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)))</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="o">*</span><span class="n">angs</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">all_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">plot_projection</span><span class="p">(</span><span class="n">fig_ax</span><span class="o">=</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">),</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="OpenKnot.alexander_polynomials"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.alexander_polynomials">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">alexander_polynomials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">recalculate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">zero_centroid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">optimise_closure</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a list of Alexander polynomials for the knot, closing</span>
<span class="sd">        on a sphere of the given radius, with the given number of sample</span>
<span class="sd">        points approximately evenly distributed on the sphere.</span>

<span class="sd">        The results are cached by number of samples and radius.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_samples : int</span>
<span class="sd">            The number of points on the sphere to sample. Defaults to 10.</span>
<span class="sd">        optimise_closure: bool</span>
<span class="sd">            If True, doesn&#39;t really close on a sphere but at infinity.</span>
<span class="sd">            This lets the calculation be optimised slightly, and so is the</span>
<span class="sd">            default.</span>
<span class="sd">        radius : float</span>
<span class="sd">            The radius of the sphere on which to close the knot. Defaults</span>
<span class="sd">            to None, which picks 10 times the largest Cartesian deviation</span>
<span class="sd">            from 0. This is *only* used if optimise_closure=False.</span>
<span class="sd">        zero_centroid : bool</span>
<span class="sd">            Whether to first move the average position of vertices to</span>
<span class="sd">            (0, 0, 0). Defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : ndarray</span>
<span class="sd">            A number_of_samples by 3 array of angles and alexander</span>
<span class="sd">            polynomials.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">zero_centroid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">recalculate</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_alexanders</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">number_of_samples</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_alexanders</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_alexanders</span><span class="p">[(</span><span class="n">number_of_samples</span><span class="p">,</span>
                                                <span class="n">radius</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cached_alexanders</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">number_of_samples</span><span class="p">)</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">cache_radius</span> <span class="o">=</span> <span class="n">radius</span>

        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="c1"># Not guaranteed to give 10* the real radius, but good enough</span>

        <span class="n">print_dist</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">3000.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">print_dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_vprint</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">i = </span><span class="si">{}</span><span class="s1"> / </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)),</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">Knot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="o">*</span><span class="n">angs</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span> 
                <span class="k">if</span> <span class="n">zero_centroid</span><span class="p">:</span>
                    <span class="n">k</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">optimise_closure</span><span class="p">:</span>
                    <span class="n">cs</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">raw_crossings</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">closure_cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">))</span> <span class="o">|</span>
                                                <span class="p">((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">)))</span>
                        <span class="n">indices</span> <span class="o">=</span> <span class="n">closure_cs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                            <span class="n">cs</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">gc</span> <span class="o">=</span> <span class="n">GaussCode</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
                    <span class="n">gc</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
                    <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">angs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alexander</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">points</span>
                    <span class="n">closure_point</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span>
                    <span class="n">closure_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">radius</span>
                    <span class="n">k</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">points</span><span class="p">,</span> <span class="n">closure_point</span><span class="p">])</span>

                    <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">angs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span><span class="o">.</span><span class="n">alexander_polynomial</span><span class="p">()])</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failed_case</span> <span class="o">=</span> <span class="n">k</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_alexanders</span><span class="p">[</span>
            <span class="p">(</span><span class="n">number_of_samples</span><span class="p">,</span> <span class="n">cache_radius</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span></div>

<div class="viewcode-block" id="OpenKnot.closure_alexander_polynomial"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.closure_alexander_polynomial">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">closure_alexander_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns the Alexander polynomial of the knot, when projected in</span>
<span class="sd">        the z plane after rotating the given theta and phi to the</span>
<span class="sd">        North pole.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : float</span>
<span class="sd">            The sphere angle theta</span>
<span class="sd">        phi : float</span>
<span class="sd">            The sphere angle phi</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">Knot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">))</span>

        <span class="n">cs</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">raw_crossings</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">closure_cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">))</span> <span class="o">|</span>
                                    <span class="p">((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">)))</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">closure_cs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">cs</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="n">GaussCode</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">alexander</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>
        

<div class="viewcode-block" id="OpenKnot.alexander_fractions"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.alexander_fractions">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">alexander_fractions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns each of the Alexander polynomials from</span>
<span class="sd">        self.alexander_polynomials, with the fraction of that type.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alexander_polynomials</span><span class="p">(</span>
            <span class="n">number_of_samples</span><span class="o">=</span><span class="n">number_of_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">alexs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">polys</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="n">fracs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alexs</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">alex</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">alexs</span><span class="p">):</span>
            <span class="n">fracs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">alex</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alexs</span> <span class="o">==</span> <span class="n">alex</span><span class="p">)</span> <span class="o">/</span> <span class="n">length</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fracs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">_alexander_map_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alexander_polynomials</span><span class="p">(</span>
            <span class="n">number_of_samples</span><span class="o">=</span><span class="n">number_of_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">griddata</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gall_peters</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="n">interpolation_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="mf">1.57</span><span class="o">*</span><span class="n">interpolation</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span>
                                       <span class="o">-</span><span class="mf">2.</span><span class="p">:</span><span class="mf">2.</span><span class="p">:</span><span class="n">interpolation</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">]</span>
        <span class="c1"># interpolation_points = np.mgrid[0:2 * np.pi:157j,</span>
        <span class="c1">#                        -2.:2.:100j]</span>
        <span class="c1"># &#39;&#39;&#39;interpolation_points = np.mgrid[-np.pi:np.pi:157j,</span>
        <span class="c1">#                        -np.pi/2:np.pi/2:100j]&#39;&#39;&#39;</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">polys</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                          <span class="nb">tuple</span><span class="p">(</span><span class="n">interpolation_points</span><span class="p">),</span>
                          <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">positions</span><span class="p">,</span> <span class="n">values</span>

<div class="viewcode-block" id="OpenKnot.plot_alexander_map"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.plot_alexander_map">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot_alexander_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                           <span class="n">scatter_points</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;imshow&#39;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Creates (and returns) a projective diagram showing each</span>
<span class="sd">        different Alexander polynomial in a different colour according</span>
<span class="sd">        to a closure on a far away point in this direction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_samples : int</span>
<span class="sd">            The number of points on the sphere to close at.</span>
<span class="sd">        scatter_points : bool</span>
<span class="sd">            If True, plots a dot at each point on the map projection</span>
<span class="sd">            where a closure was made.</span>
<span class="sd">        mode : str</span>
<span class="sd">            &#39;imshow&#39; to plot the pixels of an image, otherwise plots</span>
<span class="sd">            filled contours. Defaults to &#39;imshow&#39;.</span>
<span class="sd">        interpolation : int</span>
<span class="sd">            The (short) side length of the interpolation grid on which</span>
<span class="sd">            the map projection is made. Defaults to 100.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">positions</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alexander_map_values</span><span class="p">(</span>
            <span class="n">number_of_samples</span><span class="p">,</span>
            <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">)</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;fig = plt.figure(figsize=(10, 5))</span>
<span class="sd">        ax = fig.add_subplot(111, projection=&quot;mollweide&quot;)</span>
<span class="sd">        ax.grid(True)&#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;imshow&#39;</span><span class="p">:</span>
            <span class="n">cax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span>
                        <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.1</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.565</span><span class="o">*</span><span class="n">interpolation</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.995</span><span class="o">*</span><span class="n">interpolation</span><span class="p">)</span>

        <span class="n">im_positions</span> <span class="o">=</span> <span class="n">positions</span><span class="o">*</span><span class="mi">25</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">interpolation</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">)</span>
        <span class="n">im_positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span>
        <span class="n">im_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">49.</span><span class="o">*</span><span class="p">(</span><span class="n">interpolation</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="k">if</span> <span class="n">scatter_points</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">im_positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">im_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                       <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>



<div class="viewcode-block" id="OpenKnot.virtual_check"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.virtual_check">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">virtual_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Takes an open curve and checks (for the default projection) if its</span>
<span class="sd">        Gauss code corresponds to a virtual knot or not. Returns a</span>
<span class="sd">        Boolean of this information.</span>

<span class="sd">        .. warning:: This only checks the distance by which entries in</span>
<span class="sd">                     the Gauss code are separated, it is *not*</span>
<span class="sd">                     guaranteed to detect virtual knots.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        virtual : bool</span>
<span class="sd">            True if the Gauss code corresponds to a virtual knot. False</span>
<span class="sd">            otherwise.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">gauss_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">()</span><span class="o">.</span><span class="n">_gauss_code</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gauss_code</span><span class="p">)</span>
        <span class="n">total_crossings</span> <span class="o">=</span> <span class="n">l</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">crossing_counter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">virtual</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">crossing_number</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">()</span><span class="o">.</span><span class="n">crossing_numbers</span><span class="p">:</span>
            <span class="n">occurences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">gauss_code</span> <span class="o">==</span> <span class="n">crossing_number</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">first_occurence</span> <span class="o">=</span> <span class="n">occurences</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">second_occurence</span> <span class="o">=</span> <span class="n">occurences</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">crossing_difference</span> <span class="o">=</span> <span class="n">second_occurence</span> <span class="o">-</span> <span class="n">first_occurence</span>

            <span class="k">if</span> <span class="n">crossing_difference</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="OpenKnot.virtual_checks"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.virtual_checks">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">virtual_checks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
                                        <span class="n">zero_centroid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a list of virtual Booleans for the curve with a given number </span>
<span class="sd">        if projections taken from directions approximately evenly distributed. </span>
<span class="sd">        A value of True corresponds to the projection giving a virtual knot, </span>
<span class="sd">        with False returned otherwise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_samples : int</span>
<span class="sd">            The number of points on the sphere to project from. Defaults to 10.</span>
<span class="sd">        zero_centroid : bool</span>
<span class="sd">            Whether to first move the average position of vertices to</span>
<span class="sd">            (0, 0, 0). Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : ndarray</span>
<span class="sd">            A number_of_samples by 3 array of angles and virtual Booleans</span>
<span class="sd">            (True if virtual, False otherwise)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">zero_centroid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">number_of_samples</span><span class="p">)</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">print_dist</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">3000.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">print_dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vprint</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">i = </span><span class="si">{}</span><span class="s1"> / </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)),</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="o">*</span><span class="n">angs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">zero_centroid</span><span class="p">:</span>
                <span class="n">k</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>
            <span class="n">isvirtual</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">virtual_check</span><span class="p">()</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">angs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">isvirtual</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span></div>

<div class="viewcode-block" id="OpenKnot.virtual_fractions"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.virtual_fractions">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">virtual_fractions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns each of the virtual booleans from</span>
<span class="sd">        self.virtual.check.projections, with the fraction of each type.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_checks</span><span class="p">(</span>
            <span class="n">number_of_samples</span><span class="o">=</span><span class="n">number_of_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">alexs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">polys</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="n">fracs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alexs</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">alex</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">alexs</span><span class="p">):</span>
            <span class="n">fracs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">alex</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alexs</span> <span class="o">==</span> <span class="n">alex</span><span class="p">)</span> <span class="o">/</span> <span class="n">length</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fracs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>
        
    <span class="k">def</span><span class="w"> </span><span class="nf">_virtual_map_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_checks</span><span class="p">(</span>
            <span class="n">number_of_samples</span><span class="o">=</span><span class="n">number_of_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">griddata</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gall_peters</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="n">interpolation_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span><span class="mi">157</span><span class="n">j</span><span class="p">,</span>
                               <span class="o">-</span><span class="mf">2.</span><span class="p">:</span><span class="mf">2.</span><span class="p">:</span><span class="mi">100</span><span class="n">j</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">polys</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                          <span class="nb">tuple</span><span class="p">(</span><span class="n">interpolation_points</span><span class="p">),</span>
                          <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">positions</span><span class="p">,</span> <span class="n">values</span>

<div class="viewcode-block" id="OpenKnot.plot_virtual_map"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.plot_virtual_map">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot_virtual_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                         <span class="n">scatter_points</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;imshow&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Creates (and returns) a projective diagram showing each</span>
<span class="sd">        different virtual Boolean in a different colour according</span>
<span class="sd">        to a projection in this direction.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">positions</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_map_values</span><span class="p">(</span><span class="n">number_of_samples</span><span class="p">)</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;imshow&#39;</span><span class="p">:</span>
            <span class="n">cax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span>
                        <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.1</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">156.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">)</span>

        <span class="n">im_positions</span> <span class="o">=</span> <span class="n">positions</span> <span class="o">*</span> <span class="mi">25</span>
        <span class="n">im_positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span>
        <span class="n">im_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">49.5</span>
        <span class="k">if</span> <span class="n">scatter_points</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">im_positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">im_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                       <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="OpenKnot.plot_virtual_shell"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.plot_virtual_shell">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot_virtual_shell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                           <span class="n">zero_centroid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">sphere_radius_factor</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span>
                           <span class="n">opacity</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Plots the curve in 3d via self.plot(), along with a translucent</span>
<span class="sd">        sphere coloured according to whether or not the projection from this</span>
<span class="sd">        point corresponds to a virtual knot or not.</span>

<span class="sd">        Parameters are all passed to </span>
<span class="sd">        :meth:`OpenKnot.virtual_checks`, except opacity and kwargs </span>
<span class="sd">        which are given to mayavi.mesh, and sphere_radius_factor which gives </span>
<span class="sd">        the radius of the enclosing sphere in terms of the maximum Cartesian</span>
<span class="sd">        distance of any point in the line from the origin.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>

        <span class="n">positions</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_map_values</span><span class="p">(</span>
            <span class="n">number_of_samples</span><span class="p">,</span> <span class="n">zero_centroid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">phis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">157</span><span class="p">)</span>

        <span class="n">thetas</span><span class="p">,</span> <span class="n">phis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">thetas</span><span class="p">,</span> <span class="n">phis</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">sphere_radius_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetas</span><span class="p">)</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetas</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phis</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetas</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phis</span><span class="p">)</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">mayavi.mlab</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">may</span>

        <span class="n">may</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">scalars</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="n">opacity</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="OpenKnot.self_linking"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.self_linking">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">self_linking</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Takes an open curve, finds its Gauss code (for the default projection)</span>
<span class="sd">        and calculates its self linking number, J(K). See Kauffman 2004 for</span>
<span class="sd">        more information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : self_link_counter : int</span>
<span class="sd">            The self linking number of the open curve</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">))</span>

        <span class="c1"># gausscode = k.gauss_code(virtual_closure=True)</span>
        <span class="c1"># gausscode.simplify()</span>
        <span class="c1"># gausscode = gausscode.without_virtual()._gauss_code[0]</span>
        <span class="n">gausscode</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">()</span><span class="o">.</span><span class="n">_gauss_code</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># gausscode = k.gauss_code()._gauss_code[0]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gausscode</span><span class="p">)</span>

        <span class="n">self_linking_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gausscode</span><span class="p">):</span>
            <span class="n">number</span><span class="p">,</span> <span class="n">over_under</span><span class="p">,</span> <span class="n">orientation</span> <span class="o">=</span> <span class="n">row</span>
            <span class="k">if</span> <span class="n">number</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">-</span> <span class="n">cache</span><span class="p">[</span><span class="n">number</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">self_linking_counter</span> <span class="o">+=</span> <span class="n">orientation</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

        <span class="k">return</span> <span class="n">self_linking_counter</span></div>
                    
    <span class="k">def</span><span class="w"> </span><span class="nf">closure_alexander</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves.knot</span><span class="w"> </span><span class="kn">import</span> <span class="n">Knot</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">Knot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">))</span>

        <span class="n">cs</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">raw_crossings</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">closure_cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">))</span> <span class="o">|</span>
                                    <span class="p">((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">)))</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">closure_cs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">cs</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">gausscode</span> <span class="o">=</span> <span class="n">GaussCode</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gausscode</span><span class="p">)</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.invariants</span><span class="w"> </span><span class="kn">import</span> <span class="n">alexander</span>
        <span class="k">return</span> <span class="n">alexander</span><span class="p">(</span><span class="n">gausscode</span><span class="p">)</span>
                

<div class="viewcode-block" id="OpenKnot.self_linkings"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.self_linkings">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">self_linkings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                      <span class="n">zero_centroid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a list of self linking numbers for the curve with a given</span>
<span class="sd">        number of projections taken from directions approximately evenly</span>
<span class="sd">        distributed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_samples : int</span>
<span class="sd">            The number of points on the sphere to project from. Defaults to 10.</span>
<span class="sd">        zero_centroid : bool</span>
<span class="sd">            Whether to first move the average position of vertices to</span>
<span class="sd">            (0, 0, 0). Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : ndarray</span>
<span class="sd">            A number_of_samples by 3 array of angles and self linking number</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">zero_centroid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">number_of_samples</span><span class="p">)</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">print_dist</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">3000.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">print_dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vprint</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">i = </span><span class="si">{}</span><span class="s1"> / </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)),</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="o">*</span><span class="n">angs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">zero_centroid</span><span class="p">:</span>
                <span class="n">k</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>
            <span class="n">self_linking</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">self_linking</span><span class="p">()</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">angs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">self_linking</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span></div>

<div class="viewcode-block" id="OpenKnot.self_linking_fractions"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.self_linking_fractions">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">self_linking_fractions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns each of the self linking numbers from</span>
<span class="sd">        self.virtual.self_link.projections, with the fraction of each type.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">self_linkings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">self_linkings</span><span class="p">(</span>
            <span class="n">number_of_samples</span><span class="o">=</span><span class="n">number_of_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">self_linkings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">self_linkings</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="n">fracs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">self_linkings</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">alex</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">self_linkings</span><span class="p">):</span>
            <span class="n">fracs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">alex</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">self_linkings</span> <span class="o">==</span> <span class="n">alex</span><span class="p">)</span> <span class="o">/</span> <span class="n">length</span><span class="p">))</span>
        <span class="c1"># fracs = np.array(fracs)</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fracs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>
        <span class="c1">#return fracs[np.argsort(fracs[:, 1])]</span>
        
    <span class="k">def</span><span class="w"> </span><span class="nf">_self_linking_map_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">self_linkings</span><span class="p">(</span>
            <span class="n">number_of_samples</span><span class="o">=</span><span class="n">number_of_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">griddata</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gall_peters</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="n">interpolation_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span><span class="mi">157</span><span class="n">j</span><span class="p">,</span>
                               <span class="o">-</span><span class="mf">2.</span><span class="p">:</span><span class="mf">2.</span><span class="p">:</span><span class="mi">100</span><span class="n">j</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">polys</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                          <span class="nb">tuple</span><span class="p">(</span><span class="n">interpolation_points</span><span class="p">),</span>
                          <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">positions</span><span class="p">,</span> <span class="n">values</span>

<div class="viewcode-block" id="OpenKnot.plot_self_linking_map"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.plot_self_linking_map">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot_self_linking_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                           <span class="n">scatter_points</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;imshow&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Creates (and returns) a projective diagram showing each</span>
<span class="sd">        different self linking number in a different colour according</span>
<span class="sd">        to a projection in this direction.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">positions</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_self_linking_map_values</span><span class="p">(</span><span class="n">number_of_samples</span><span class="p">)</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;imshow&#39;</span><span class="p">:</span>
            <span class="n">cax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span>
                        <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.1</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">156.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">)</span>

        <span class="n">im_positions</span> <span class="o">=</span> <span class="n">positions</span> <span class="o">*</span> <span class="mi">25</span>
        <span class="n">im_positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span>
        <span class="n">im_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">49.5</span>
        <span class="k">if</span> <span class="n">scatter_points</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">im_positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">im_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                       <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="OpenKnot.plot_self_linking_shell"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.plot_self_linking_shell">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot_self_linking_shell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Plots the curve in 3d via self.plot(), along with a translucent</span>
<span class="sd">        sphere coloured by the self linking number obtained by projecting from</span>
<span class="sd">        this point.</span>

<span class="sd">        Parameters are all passed to </span>
<span class="sd">        :meth:`OpenKnot.virtual_checks`, except opacity and kwargs </span>
<span class="sd">        which are given to mayavi.mesh, and sphere_radius_factor which gives </span>
<span class="sd">        the radius of the enclosing sphere in terms of the maximum Cartesian</span>
<span class="sd">        distance of any point in the line from the origin.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">plot_shell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_self_linking_map_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span>
                   <span class="n">number_of_samples</span><span class="o">=</span><span class="n">number_of_samples</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="OpenKnot.plot_alexander_shell"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.plot_alexander_shell">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot_alexander_shell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;mesh&#39;</span><span class="p">,</span>
                             <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Plots the curve in 3d via self.plot(), along with a translucent</span>
<span class="sd">        sphere coloured by the type of knot obtained by closing on each</span>
<span class="sd">        point.</span>

<span class="sd">        Parameters are all passed to :meth:`OpenKnot.alexander_polynomials`,</span>
<span class="sd">        except opacity and kwargs which are given to mayavi.mesh, and</span>
<span class="sd">        sphere_radius_factor which gives the radius of the enclosing</span>
<span class="sd">        sphere in terms of the maximum Cartesian distance of any point</span>
<span class="sd">        in the line from the origin.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">self_radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">self_radii</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;radius is&#39;</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;mesh&#39;</span><span class="p">:</span>
            <span class="n">plot_sphere_shell_vispy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">closure_alexander_polynomial</span><span class="p">,</span>
                                    <span class="n">number_of_samples</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="p">,</span>
                                    <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;crude&#39;</span><span class="p">:</span>
            <span class="n">plot_shell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_alexander_map_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span>
                       <span class="n">number_of_samples</span><span class="o">=</span><span class="n">number_of_samples</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="OpenKnot.alexander_polynomials_multiroots"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.alexander_polynomials_multiroots">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">alexander_polynomials_multiroots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                         <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">zero_centroid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a list of Alexander polynomials for the knot, closing</span>
<span class="sd">        on a sphere of the given radius, with the given number of sample</span>
<span class="sd">        points approximately evenly distributed on the sphere. The</span>
<span class="sd">        Alexander polynomials are found at three different roots (2, 3</span>
<span class="sd">        and 4) and a the knot types corresponding to these roots are</span>
<span class="sd">        returned also.</span>

<span class="sd">        The results are cached by number of samples and radius.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_samples : int</span>
<span class="sd">            The number of points on the sphere to sample. Defaults to 10.</span>
<span class="sd">        radius : float</span>
<span class="sd">            The radius of the sphere on which to close the knot. Defaults</span>
<span class="sd">            to None, which picks 10 times the largest Cartesian deviation</span>
<span class="sd">            from 0.</span>
<span class="sd">        zero_centroid : bool</span>
<span class="sd">            Whether to first move the average position of vertices to</span>
<span class="sd">            (0, 0, 0). Defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : ndarray</span>
<span class="sd">            A number_of_samples by 3 array of angles and alexander</span>
<span class="sd">            polynomials.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.catalogue.identify</span><span class="w"> </span><span class="kn">import</span> <span class="n">from_invariants</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.catalogue.database</span><span class="w"> </span><span class="kn">import</span> <span class="n">Knot</span> <span class="k">as</span> <span class="n">dbknot</span>

        <span class="k">if</span> <span class="n">zero_centroid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_alexanders</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">number_of_samples</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_alexanders</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_alexanders</span><span class="p">[(</span><span class="n">number_of_samples</span><span class="p">,</span>
                                                <span class="n">radius</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cached_alexanders</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">number_of_samples</span><span class="p">)</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">cache_radius</span> <span class="o">=</span> <span class="n">radius</span>

        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="c1"># Not guaranteed to give 10* the real radius, but good enough</span>

        <span class="n">print_dist</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">3000.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">print_dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vprint</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">i = </span><span class="si">{}</span><span class="s1"> / </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)),</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">Knot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="o">*</span><span class="n">angs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">zero_centroid</span><span class="p">:</span>
                <span class="n">k</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">points</span>
            <span class="n">closure_point</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">closure_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">radius</span>
            <span class="n">k</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">points</span><span class="p">,</span> <span class="n">closure_point</span><span class="p">])</span>
            <span class="n">root_at_two</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">alexander_at_root</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">root_at_three</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">alexander_at_root</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">root_at_four</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">alexander_at_root</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">k_gauss_code</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">()</span>
            <span class="n">k_gauss_code</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="n">max_crossings</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_gauss_code</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_crossings</span> <span class="o">&gt;</span> <span class="mi">17</span><span class="p">:</span>
                <span class="n">max_crossings</span> <span class="o">=</span> <span class="mi">18</span>
            <span class="n">knot_type</span> <span class="o">=</span> <span class="n">from_invariants</span><span class="p">(</span><span class="n">determinant</span><span class="o">=</span><span class="n">root_at_two</span><span class="p">,</span> <span class="n">alex_imag_3</span><span class="o">=</span><span class="n">root_at_three</span><span class="p">,</span>
                                        <span class="n">alex_imag_4</span><span class="o">=</span><span class="n">root_at_four</span><span class="p">,</span>
                                        <span class="n">other</span><span class="o">=</span><span class="p">[</span><span class="n">dbknot</span><span class="o">.</span><span class="n">min_crossings</span> <span class="o">&lt;=</span> <span class="n">max_crossings</span><span class="p">])</span>
            <span class="n">knot_type</span> <span class="o">=</span> <span class="n">knot_db_to_string</span><span class="p">(</span><span class="n">knot_type</span><span class="p">)</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">angs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">root_at_two</span><span class="p">,</span> <span class="n">root_at_three</span><span class="p">,</span> <span class="n">root_at_four</span><span class="p">,</span> <span class="n">max_crossings</span><span class="p">,</span>
                          <span class="n">knot_type</span><span class="p">])</span>

            <span class="c1"># self._cached_alexanders[</span>
            <span class="c1">#      (number_of_samples, cache_radius)] = np.array(polys)</span>

        <span class="k">return</span> <span class="n">polys</span></div>

<div class="viewcode-block" id="OpenKnot.multiroots_fractions"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.multiroots_fractions">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">multiroots_fractions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns each of the knot types from</span>
<span class="sd">        self.alexander_polynomials_multiroots, with the fraction of that type.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">knot_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alexander_polynomials_multiroots</span><span class="p">(</span>
            <span class="n">number_of_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">knot_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">closures</span> <span class="ow">in</span> <span class="n">knot_info</span><span class="p">:</span>
            <span class="n">knot_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closures</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
        <span class="n">knot_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">knot_types</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span> <span class="c1">#flattens list</span>
        <span class="n">knot_frequency</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">knot_types</span><span class="p">)</span>
        <span class="n">common</span> <span class="o">=</span> <span class="n">knot_frequency</span><span class="o">.</span><span class="n">most_common</span><span class="p">()</span>
        <span class="n">list_common</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">common</span><span class="p">]</span>
        <span class="n">list_common_fractions</span> <span class="o">=</span> <span class="p">[[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">number_of_samples</span><span class="p">)]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">list_common</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">list_common_fractions</span></div>

<div class="viewcode-block" id="OpenKnot.generalised_alexander"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.generalised_alexander">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">generalised_alexander</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the generalised Alexander polynomial for the default projection</span>
<span class="sd">        of the open knot</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">gauss_code_crossings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">()</span><span class="o">.</span><span class="n">_gauss_code</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">gauss_code_over_under</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">()</span><span class="o">.</span><span class="n">_gauss_code</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">gauss_code_orientations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">()</span><span class="o">.</span><span class="n">_gauss_code</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="n">m_plus</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">**-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="n">m_minus</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="o">**-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">y</span><span class="o">**-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="o">**-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">num_crossings</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">())</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_crossings</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span><span class="n">num_crossings</span><span class="p">)</span>
        <span class="n">permutation_matrix</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_crossings</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_crossings</span><span class="p">)</span>

        <span class="n">arc_labels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">gauss_code_crossings</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gauss_code_crossings</span><span class="p">)):</span>
            <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span>

        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">crossing_number</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">()</span><span class="o">.</span><span class="n">crossing_numbers</span><span class="p">:</span>
            <span class="n">occurrences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">gauss_code_crossings</span> <span class="o">==</span> <span class="n">crossing_number</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">gauss_code_orientations</span><span class="p">[</span><span class="n">occurrences</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">m_plus</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">m_minus</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">counter</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span><span class="n">counter</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gauss_code_crossings</span><span class="p">)):</span>
            <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gauss_code_crossings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gauss_code_orientations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span>
                                <span class="n">gauss_code_over_under</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1">#-1 = r, +1 = l</span>
            <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">gauss_code_crossings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">gauss_code_orientations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span>
                                  <span class="n">gauss_code_over_under</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1">#-1 = r, +1 = l</span>

        <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">crossing_number</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">()</span><span class="o">.</span><span class="n">crossing_numbers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gauss_code_crossings</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crossing_number</span><span class="p">:</span>
                    <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span>
                <span class="k">if</span> <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crossing_number</span><span class="p">:</span>
                    <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arc_labels</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="c1">#bottom right</span>
                    <span class="n">permutation_matrix</span><span class="p">[</span><span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#bottom left</span>
                    <span class="n">permutation_matrix</span><span class="p">[</span><span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1">#upper right</span>
                    <span class="n">permutation_matrix</span><span class="p">[</span><span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#upper left</span>
                    <span class="n">permutation_matrix</span><span class="p">[</span><span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">arc_labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">writhe</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">gauss_code_orientations</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">writhe</span> <span class="o">*</span> <span class="p">((</span><span class="n">matrix</span> <span class="o">-</span> <span class="n">permutation_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">det</span><span class="p">())</span></div>

<div class="viewcode-block" id="OpenKnot.projection_invariant"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.projection_invariant">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">projection_invariant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        First checks if the projection of an open curve is virtual or classical. If virtual,</span>
<span class="sd">        a virtual knot invariant is calculated. Otherwise a classical invariant is calculated.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">is_virtual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_virtual</span><span class="p">:</span>
            <span class="k">return</span><span class="p">([</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">self_linking</span><span class="p">()])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.invariants</span><span class="w"> </span><span class="kn">import</span> <span class="n">alexander</span>
            <span class="k">return</span><span class="p">([</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="n">alexander</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">(),</span> <span class="n">variable</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">quadrant</span><span class="o">=</span><span class="s1">&#39;lr&#39;</span><span class="p">,</span>
                                    <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">slip_vassiliev_degree_2_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">recalculate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves.rotation</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">get_rotation_angles</span><span class="p">,</span>
                                                  <span class="n">rotate_to_top</span><span class="p">)</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves</span><span class="w"> </span><span class="kn">import</span> <span class="n">Knot</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    
        <span class="n">v2s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">))</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">_slip_vassiliev_degree_2_projection</span><span class="p">()</span>
            <span class="n">v2s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v2s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_slip_vassiliev_degree_2_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">()</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.writhes</span><span class="w"> </span><span class="kn">import</span> <span class="n">slip_vassiliev_2</span>
        <span class="k">return</span> <span class="n">slip_vassiliev_2</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>

<div class="viewcode-block" id="OpenKnot.vassiliev_degree_2_average"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.OpenKnot.vassiliev_degree_2_average">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vassiliev_degree_2_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">recalculate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns the average Vassliev degree 2 invariant calculated by</span>
<span class="sd">        averaging its combinatorial value over many different</span>
<span class="sd">        projection directions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples : int</span>
<span class="sd">            The number of directions to average over. Defaults to 10.</span>
<span class="sd">        recalculate : bool</span>
<span class="sd">            Whether to recalculate the writhe even if a cached result</span>
<span class="sd">            is available. Defaults to False.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            These are passed directly to :meth:`raw_crossings`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cached_v2</span> <span class="ow">and</span>
            <span class="n">samples</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_v2</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="n">recalculate</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_v2</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves.rotation</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">get_rotation_angles</span><span class="p">,</span>
                                                  <span class="n">rotate_to_top</span><span class="p">)</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves</span><span class="w"> </span><span class="kn">import</span> <span class="n">Knot</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    
        <span class="n">v2s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">))</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">_vassiliev_degree_2_projection</span><span class="p">()</span>
            <span class="n">v2s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v2s</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_v2</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">_vassiliev_degree_2_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves</span><span class="w"> </span><span class="kn">import</span> <span class="n">Knot</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">Knot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">k</span><span class="o">.</span><span class="n">vassiliev_degree_2</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">include_closure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">vassiliev_degree_3_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">recalculate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cached_v3</span> <span class="ow">and</span>
            <span class="n">samples</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_v3</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="n">recalculate</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_v3</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves.rotation</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_rotation_angles</span><span class="p">,</span> <span class="n">rotate_to_top</span>            
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves</span><span class="w"> </span><span class="kn">import</span> <span class="n">Knot</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    
        <span class="n">v3s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">))</span>
            <span class="n">v3</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">_vassiliev_degree_3_projection</span><span class="p">()</span>
            <span class="n">v3s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signed</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">v3s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">signed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">v3s</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v3s</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v3s</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_v3</span><span class="p">[(</span><span class="n">samples</span><span class="p">,</span> <span class="n">signed</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_vassiliev_degree_3_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves</span><span class="w"> </span><span class="kn">import</span> <span class="n">Knot</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">Knot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">k</span><span class="o">.</span><span class="n">vassiliev_degree_3</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">include_closure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">virtual_vassiliev_degree_3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.invariants</span><span class="w"> </span><span class="kn">import</span> <span class="n">virtual_vassiliev_degree_3</span>
        <span class="k">return</span> <span class="n">virtual_vassiliev_degree_3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_determinants_and_self_linkings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">recalculate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">zero_centroid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">zero_centroid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">number_of_samples</span><span class="p">)</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">self_linkings</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">cache_radius</span> <span class="o">=</span> <span class="n">radius</span>

        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="c1"># Not guaranteed to give 10* the real radius, but good enough</span>

        <span class="n">print_dist</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">3000.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">print_dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vprint</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">i = </span><span class="si">{}</span><span class="s1"> / </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)),</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">Knot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="o">*</span><span class="n">angs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">zero_centroid</span><span class="p">:</span>
                <span class="n">k</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">raw_crossings</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">closure_cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">))</span> <span class="o">|</span>
                                        <span class="p">((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">)))</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">closure_cs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                    <span class="n">cs</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">gc</span> <span class="o">=</span> <span class="n">GaussCode</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">angs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alexander</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>

            <span class="c1"># Remove closing crossings to calculate self linking</span>
            <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">keeps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">:</span>
                <span class="n">keeps</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">keeps</span><span class="p">]</span>
            <span class="n">gausscode</span> <span class="o">=</span> <span class="n">GaussCode</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span><span class="o">.</span><span class="n">_gauss_code</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gausscode</span><span class="p">)</span>
            <span class="n">self_linking_counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gausscode</span><span class="p">):</span>
                <span class="n">number</span><span class="p">,</span> <span class="n">over_under</span><span class="p">,</span> <span class="n">orientation</span> <span class="o">=</span> <span class="n">row</span>
                <span class="k">if</span> <span class="n">number</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">-</span> <span class="n">cache</span><span class="p">[</span><span class="n">number</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">self_linking_counter</span> <span class="o">+=</span> <span class="n">orientation</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
            <span class="n">self_linkings</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">angs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">self_linking_counter</span><span class="p">))</span>


        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polys</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">self_linkings</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_determinant_and_self_linking_fractions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">polys</span><span class="p">,</span> <span class="n">self_linkings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determinants_and_self_linkings</span><span class="p">(</span>
            <span class="n">number_of_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">alexs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">polys</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="n">fracs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alexs</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">alex</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">alexs</span><span class="p">):</span>
            <span class="n">fracs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">alex</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alexs</span> <span class="o">==</span> <span class="n">alex</span><span class="p">)</span> <span class="o">/</span> <span class="n">length</span><span class="p">))</span>

        <span class="n">det_fracs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fracs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


        <span class="n">self_linkings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">self_linkings</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="n">fracs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">self_linkings</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">linking</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">self_linkings</span><span class="p">):</span>
            <span class="n">fracs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">linking</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">self_linkings</span> <span class="o">==</span> <span class="n">linking</span><span class="p">)</span> <span class="o">/</span> <span class="n">length</span><span class="p">))</span>

        <span class="n">self_linking_fracs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fracs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">det_fracs</span><span class="p">,</span> <span class="n">self_linking_fracs</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_closure_and_projection_invariants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                           <span class="n">recalculate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">zero_centroid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">zero_centroid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">number_of_samples</span><span class="p">)</span>

        <span class="n">closure_knotted</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">projection_virtual</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">projection_knotted</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">cache_radius</span> <span class="o">=</span> <span class="n">radius</span>

        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="c1"># Not guaranteed to give 10* the real radius, but good enough</span>

        <span class="n">print_dist</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">3000.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">print_dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vprint</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">i = </span><span class="si">{}</span><span class="s1"> / </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)),</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">Knot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="o">*</span><span class="n">angs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">zero_centroid</span><span class="p">:</span>
                <span class="n">k</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">raw_crossings</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">closure_cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">))</span> <span class="o">|</span>
                                        <span class="p">((</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">)))</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">closure_cs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                    <span class="n">cs</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">gc</span> <span class="o">=</span> <span class="n">GaussCode</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="n">is_knotted</span> <span class="o">=</span> <span class="p">(</span><span class="n">alexander</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1.5</span>
            <span class="n">closure_knotted</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">angs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">is_knotted</span><span class="p">])</span>

            <span class="c1"># Remove closing crossings to calculate self linking</span>
            <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cs</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">keeps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">:</span>
                <span class="n">keeps</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">keeps</span><span class="p">]</span>
            <span class="n">rep</span> <span class="o">=</span> <span class="n">Representation</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
            <span class="n">is_virtual</span> <span class="o">=</span> <span class="n">rep</span><span class="o">.</span><span class="n">self_linking</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="n">projection_virtual</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">angs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">is_virtual</span><span class="p">))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_virtual</span><span class="p">:</span>
                <span class="n">is_knotted</span> <span class="o">=</span> <span class="n">alexander</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.5</span>
                <span class="n">projection_knotted</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">angs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">is_knotted</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">projection_knotted</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">angs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">False</span><span class="p">])</span>


        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">closure_knotted</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">projection_virtual</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">projection_knotted</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_closure_and_projection_knotted_fractions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">polys</span><span class="p">,</span> <span class="n">self_linkings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determinants_and_self_linkings</span><span class="p">(</span>
            <span class="n">number_of_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ck</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="n">pk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closure_and_projection_invariants</span><span class="p">(</span><span class="n">number_of_samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">ck_fraction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">ck</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">pv_fraction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">pv</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ck_fraction</span><span class="p">,</span> <span class="n">pv_fraction</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">pv</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span> <span class="o">|</span>
                                                   <span class="n">pk</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">plot_vassiliev_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">max_crossings</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vassiliev_degree_2_average</span><span class="p">()</span>
        <span class="n">v3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vassiliev_degree_3_average</span><span class="p">()</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.catalogue.identify</span><span class="w"> </span><span class="kn">import</span> <span class="n">from_invariants</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="n">ks</span> <span class="o">=</span> <span class="n">from_invariants</span><span class="p">(</span><span class="n">max_crossings</span><span class="o">=</span><span class="n">max_crossings</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">:</span>
            <span class="n">kv2</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">vassiliev_2</span>
            <span class="n">kv3</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">vassiliev_3</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">kv2</span><span class="p">],</span> <span class="p">[</span><span class="n">kv3</span><span class="p">])</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;v2&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;v3&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">v2</span><span class="p">],</span> <span class="p">[</span><span class="n">v3</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="gall_peters"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.gall_peters">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">gall_peters</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Converts spherical coordinates to the Gall-Peters</span>
<span class="sd">    projection of the sphere, an area-preserving projection in</span>
<span class="sd">    the shape of a Rectangle.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : float</span>
<span class="sd">        The latitude, in radians.</span>
<span class="sd">    phi : float</span>
<span class="sd">        The longitude, in radians.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">theta</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span></div>

<div class="viewcode-block" id="mollweide"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.mollweide">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">mollweide</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Converts spherical coordinates to the Mollweide</span>
<span class="sd">    projection of the sphere, an area-preserving projection in</span>
<span class="sd">    the shape of an ellipse.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    phi : float</span>
<span class="sd">        The latitude, in radians.</span>
<span class="sd">    lambda_ : float</span>
<span class="sd">        The longitude, in radians.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">phi</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">phi</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">theta_m</span> <span class="o">=</span> <span class="n">phi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">theta_n</span> <span class="o">=</span> <span class="n">phi</span>
        <span class="n">theta_m</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">theta_m</span> <span class="o">-</span> <span class="n">theta_n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.000001</span><span class="p">:</span>
            <span class="n">theta_n</span> <span class="o">=</span> <span class="n">theta_m</span>
            <span class="n">theta_m</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta_n</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">theta_n</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">theta_n</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span> <span class="o">/</span>
                       <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">theta_n</span><span class="p">)))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span> <span class="n">lambda_</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_m</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_m</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="knot_db_to_string"><a class="viewcode-back" href="../../../sources/spacecurves/openknot.html#pyknotid.spacecurves.openknot.knot_db_to_string">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">knot_db_to_string</span><span class="p">(</span><span class="n">database_object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Takes output from from_invariants() and returns knot type as decimal.</span>
<span class="sd">    For example: &lt;Knot 3_1&gt; becomes 3.1 and &lt;Knot K13n1496&gt; becomes 13.1496</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">db_strings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">entries</span> <span class="ow">in</span> <span class="n">database_object</span><span class="p">:</span>
        <span class="n">db_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">db_string</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span>
            <span class="n">db_string</span> <span class="o">=</span> <span class="n">db_string</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">db_string</span> <span class="o">=</span> <span class="n">db_string</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">db_string</span> <span class="o">=</span> <span class="n">db_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">db_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">db_string</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">db_strings</span></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2014-2018.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>