

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyknotid.spacecurves.knot &mdash; pyknotid 0.5.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=c3dca1ed"></script>
      <script src="../../../_static/doctools.js?v=888ff710"></script>
      <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            pyknotid
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/spacecurves/index.html">Space curve analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html">Invariants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.alexander"><code class="docutils literal notranslate"><span class="pre">alexander()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.alexander_cypari"><code class="docutils literal notranslate"><span class="pre">alexander_cypari()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.alexander_mathematica"><code class="docutils literal notranslate"><span class="pre">alexander_mathematica()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.alexander_maxima"><code class="docutils literal notranslate"><span class="pre">alexander_maxima()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.arnold_2St_2Jminus"><code class="docutils literal notranslate"><span class="pre">arnold_2St_2Jminus()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.arnold_2St_2Jplus"><code class="docutils literal notranslate"><span class="pre">arnold_2St_2Jplus()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.contract_points"><code class="docutils literal notranslate"><span class="pre">contract_points()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.hyperbolic_volume"><code class="docutils literal notranslate"><span class="pre">hyperbolic_volume()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.jones_mathematica"><code class="docutils literal notranslate"><span class="pre">jones_mathematica()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.second_order_writhe"><code class="docutils literal notranslate"><span class="pre">second_order_writhe()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.self_linking"><code class="docutils literal notranslate"><span class="pre">self_linking()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.vassiliev_degree_2"><code class="docutils literal notranslate"><span class="pre">vassiliev_degree_2()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.vassiliev_degree_3"><code class="docutils literal notranslate"><span class="pre">vassiliev_degree_3()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.virtual_vassiliev_degree_3"><code class="docutils literal notranslate"><span class="pre">virtual_vassiliev_degree_3()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/representations/index.html">Topological representations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/catalogue/index.html">Knot catalogue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html">Visualise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_line"><code class="docutils literal notranslate"><span class="pre">plot_line()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_projection"><code class="docutils literal notranslate"><span class="pre">plot_projection()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_shell_vispy"><code class="docutils literal notranslate"><span class="pre">plot_shell_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_sphere_lambert_sharp_vispy"><code class="docutils literal notranslate"><span class="pre">plot_sphere_lambert_sharp_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_sphere_lambert_vispy"><code class="docutils literal notranslate"><span class="pre">plot_sphere_lambert_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_sphere_mollweide_vispy"><code class="docutils literal notranslate"><span class="pre">plot_sphere_mollweide_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_sphere_shell_vispy"><code class="docutils literal notranslate"><span class="pre">plot_sphere_shell_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/about.html">About pyknotid</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pyknotid</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyknotid.spacecurves.knot</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyknotid.spacecurves.knot</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Knot</span>
<span class="sd">----</span>

<span class="sd">Class for dealing with curves as knots. :class:`Knot` provides many</span>
<span class="sd">methods for topological manipulation and calculations.</span>

<span class="sd">API documentation</span>
<span class="sd">~~~~~~~~~~~~~~~~~</span>

<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves.spacecurve</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpaceCurve</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Knot&#39;</span><span class="p">,</span> <span class="p">)</span>


<div class="viewcode-block" id="Knot"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">Knot</span><span class="p">(</span><span class="n">SpaceCurve</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Class for holding the vertices of a single line, providing helper</span>
<span class="sd">    methods for convenient manipulation and analysis.</span>

<span class="sd">    A :class:`Knot` just represents a single space curve, it may be</span>
<span class="sd">    topologically trivial!</span>

<span class="sd">    This class deliberately combines methods to do many different kinds</span>
<span class="sd">    of measurements or manipulations. Some of these are externally</span>
<span class="sd">    available through other modules in pyknotid - if so, this is usually</span>
<span class="sd">    indicated in the method docstrings.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : array-like</span>
<span class="sd">        The 3d points (vertices) of a piecewise</span>
<span class="sd">        linear curve representation</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Indicates whether the Knot should print</span>
<span class="sd">        information during processing</span>
<span class="sd">    add_closure : bool</span>
<span class="sd">        If True, adds a final point to the knot near to the start point,</span>
<span class="sd">        so that it will appear visually to close when plotted.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="nd">@SpaceCurve</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Knot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_isolated</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">tangents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Knot</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">tangents</span><span class="p">(</span><span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="Knot.copy"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.copy">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns another knot with the same points and verbosity</span>
<span class="sd">        as self. Other attributes (e.g. cached crossings) are not</span>
<span class="sd">        preserved.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">Knot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="Knot.plot"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.plot">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Knot</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">reconstructed_space_curve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation</span><span class="p">()</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">Knot</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">space_curve</span><span class="p">())</span>
        <span class="n">k</span><span class="o">.</span><span class="n">zero_centroid</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">k</span>

<div class="viewcode-block" id="Knot.alexander_polynomial"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.alexander_polynomial">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">alexander_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">quadrant</span><span class="o">=</span><span class="s1">&#39;lr&#39;</span><span class="p">,</span>
                             <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the Alexander polynomial at the given point,</span>
<span class="sd">        as calculated by :func:`pyknotid.invariants.alexander`.</span>

<span class="sd">        See :func:`pyknotid.invariants.alexander` for the meanings</span>
<span class="sd">        of the named arguments.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..invariants</span><span class="w"> </span><span class="kn">import</span> <span class="n">alexander</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">alexander</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="n">variable</span><span class="p">,</span> <span class="n">quadrant</span><span class="o">=</span><span class="n">quadrant</span><span class="p">,</span>
                         <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="Knot.alexander_at_root"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.alexander_at_root">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">alexander_at_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the Alexander polynomial at the given root of unity,</span>
<span class="sd">        i.e. evaluated at exp(2 pi I / root).</span>

<span class="sd">        The result returned is the absolute value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root : int</span>
<span class="sd">            The root of unity to use, i.e. evaluating at exp(2 pi I / root).</span>
<span class="sd">            If this is iterable, this method returns a list of the results</span>
<span class="sd">            at every value of that iterable.</span>
<span class="sd">        round : bool</span>
<span class="sd">            If True and n in (1, 2, 3, 4), the result will be rounded</span>
<span class="sd">            to the nearest integer for convenience, and returned as an</span>
<span class="sd">            integer type.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            These are passed directly to :meth:`alexander_polynomial`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;__contains__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">alexander_at_root</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">root</span><span class="p">]</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1.</span><span class="n">j</span> <span class="o">/</span> <span class="n">root</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alexander_polynomial</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">round</span> <span class="ow">and</span> <span class="n">root</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Knot.determinant"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.determinant">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">determinant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the determinant of the knot. This is the Alexander</span>
<span class="sd">        polynomial evaluated at -1.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alexander_at_root</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Knot.vassiliev_degree_2"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.vassiliev_degree_2">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vassiliev_degree_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the Vassiliev invariant of degree 2 for the Knot.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        simplify : bool</span>
<span class="sd">            If True, simplifies the Gauss code of self before</span>
<span class="sd">            calculating the invariant. Defaults to True, but</span>
<span class="sd">            will work fine if you set it to False (and might even</span>
<span class="sd">            be faster).</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            These are passed directly to :meth:`gauss_code`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..invariants</span><span class="w"> </span><span class="kn">import</span> <span class="n">vassiliev_degree_2</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">vassiliev_degree_2</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Knot.vassiliev_degree_3"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.vassiliev_degree_3">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vassiliev_degree_3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">try_cython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns the Vassiliev invariant of degree 3 for the Knot.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        simplify : bool</span>
<span class="sd">            If True, simplifies the Gauss code of self before</span>
<span class="sd">            calculating the invariant. Defaults to True, but</span>
<span class="sd">            will work fine if you set it to False (and might even</span>
<span class="sd">            be faster).</span>
<span class="sd">        try_cython : bool</span>
<span class="sd">            Whether to try and use an optimised cython version of the</span>
<span class="sd">            routine (takes about 1/3 of the time for complex</span>
<span class="sd">            representations).  Defaults to True, but the python</span>
<span class="sd">            fallback will be *slower* than setting it to False if the</span>
<span class="sd">            cython function is not available.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            These are passed directly to :meth:`gauss_code`.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..invariants</span><span class="w"> </span><span class="kn">import</span> <span class="n">vassiliev_degree_3</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">vassiliev_degree_3</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">try_cython</span><span class="o">=</span><span class="n">try_cython</span><span class="p">)</span></div>

<div class="viewcode-block" id="Knot.hyperbolic_volume"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.hyperbolic_volume">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">hyperbolic_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the hyperbolic volume at the given point, via</span>
<span class="sd">        :meth:`pyknotid.representations.PlanarDiagram.as_spherogram`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        volume : float</span>
<span class="sd">            A float representing the volume returned.</span>
<span class="sd">        accuracy : int</span>
<span class="sd">            The number of digits of precision. This is significant</span>
<span class="sd">            digits, e.g. 0.00021 with 1 digit precision = 2E-4.</span>
<span class="sd">        solution_type : str</span>
<span class="sd">            The solution type of the manifold. Normally one of:</span>

<span class="sd">            - &#39;contains degenerate tetrahedra&#39; =&gt; may not be a valid result</span>
<span class="sd">            - &#39;all tetrahedra positively oriented&#39; =&gt; really probably hyperbolic</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..invariants</span><span class="w"> </span><span class="kn">import</span> <span class="n">hyperbolic_volume</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exterior_manifold</span><span class="p">()</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">accuracy</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">solution_type</span><span class="p">())</span></div>

<div class="viewcode-block" id="Knot.exterior_manifold"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.exterior_manifold">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">exterior_manifold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The knot complement manifold of self as a SnapPy class</span>
<span class="sd">        giving access to all of SnapPy&#39;s tools.</span>

<span class="sd">        This method requires that Spherogram, and possibly SnapPy,</span>
<span class="sd">        are installed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">link</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">planar_diagram</span><span class="p">()</span><span class="o">.</span><span class="n">as_spherogram</span><span class="p">()</span>
        <span class="n">link</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>  <span class="c1"># necessary with snappy 2.5, which can&#39;t deal</span>
                         <span class="c1"># with extra Reidemeister moves sometimes</span>
        <span class="k">return</span> <span class="n">link</span><span class="o">.</span><span class="n">exterior</span><span class="p">()</span></div>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crossings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&lt;Knot with </span><span class="si">{}</span><span class="s1"> points, </span><span class="si">{}</span><span class="s1"> crossings&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_crossings</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;Knot with </span><span class="si">{}</span><span class="s1"> points&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>

<div class="viewcode-block" id="Knot.identify"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.identify">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">identify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">determinant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alexander</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">roots</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                 <span class="n">min_crossings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Provides a simple interface to</span>
<span class="sd">        :func:`pyknotid.catalogue.identify.from_invariants`, by passing</span>
<span class="sd">        the given invariants. This does *not* support all invariants</span>
<span class="sd">        available, or more sophisticated identification methods,</span>
<span class="sd">        so don&#39;t be afraid to use the catalogue functions directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        determinant : bool</span>
<span class="sd">            If True, uses the knot determinant in the identification.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        alexander : bool</span>
<span class="sd">            If True-like, uses the full alexander polynomial in the</span>
<span class="sd">            identification. If the input is a dictionary of kwargs,</span>
<span class="sd">            these are passed straight to self.alexander_polynomial.</span>
<span class="sd">        roots : iterable</span>
<span class="sd">            A list of roots of unity at which to evaluate. Defaults</span>
<span class="sd">            to (2, 3, 4), the first of which is redundant with the</span>
<span class="sd">            determinant. Note that higher roots can be calculated, but</span>
<span class="sd">            aren&#39;t available in the database.</span>
<span class="sd">        min_crossings : bool</span>
<span class="sd">            If True, the output is restricted to knots with fewer crossings</span>
<span class="sd">            than the current projection of this one. Defaults to True. The</span>
<span class="sd">            only reason to turn this off is to see what other knots have</span>
<span class="sd">            the same invariants, it is never not useful for direct</span>
<span class="sd">            identification.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">roots</span><span class="p">:</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">determinant</span><span class="p">:</span>
            <span class="n">roots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">identify_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
            <span class="n">identify_kwargs</span><span class="p">[</span>
                <span class="s1">&#39;alex_imag_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">root</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alexander_at_root</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alexander</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alexander</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sym</span>
                <span class="n">alexander</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="n">sym</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)}</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alexander_polynomial</span><span class="p">(</span><span class="o">**</span><span class="n">alexander</span><span class="p">)</span>
            <span class="n">identify_kwargs</span><span class="p">[</span><span class="s1">&#39;alexander&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly</span>

        <span class="k">if</span> <span class="n">min_crossings</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>
            <span class="n">identify_kwargs</span><span class="p">[</span><span class="s1">&#39;max_crossings&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">())</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.catalogue.identify</span><span class="w"> </span><span class="kn">import</span> <span class="n">from_invariants</span>
        <span class="k">return</span> <span class="n">from_invariants</span><span class="p">(</span><span class="o">**</span><span class="n">identify_kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Knot.planar_writhe_quantities"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.planar_writhe_quantities">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">planar_writhe_quantities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_angles</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns the second order writhes, and arnold 2St+J+ values, for a</span>
<span class="sd">        range of different projection directions.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves.rotation</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
            <span class="n">get_rotation_angles</span><span class="p">,</span> <span class="n">rotate_to_top</span><span class="p">)</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="n">get_rotation_angles</span><span class="p">(</span><span class="n">num_angles</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">print_dist</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">3000.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)))</span>
        <span class="c1"># import matplotlib.pyplot as plt</span>
        <span class="c1"># fig, ax = plt.subplots()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">print_dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vprint</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">i = </span><span class="si">{}</span><span class="s1"> / </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)),</span> <span class="kc">False</span><span class="p">)</span>
            
            <span class="n">k</span> <span class="o">=</span> <span class="n">Knot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">_apply_matrix</span><span class="p">(</span><span class="n">rotate_to_top</span><span class="p">(</span><span class="o">*</span><span class="n">angs</span><span class="p">))</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">angs</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">planar_second_order_writhe</span><span class="p">(),</span>
                            <span class="n">k</span><span class="o">.</span><span class="n">arnold_2St_2Jplus</span><span class="p">()))</span>

            <span class="c1"># ax.clear()</span>
            <span class="c1"># k.plot_projection(fig_ax=(fig, ax))</span>
            <span class="c1"># fig.set_size_inches((3, 3))</span>
            <span class="c1"># ax.set_title(&#39;Wr2 = {}, unknot Wr2 = {}&#39;.format(results[-1][2],</span>
            <span class="c1">#                                                 results[-1][3]))</span>
            <span class="c1"># fig.tight_layout()</span>
            <span class="c1"># fig.savefig(&#39;planar_writhe_quantities-{:05d}.png&#39;.format(i))</span>

        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="Knot.slipknot_alexander"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.slipknot_alexander">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">slipknot_alexander</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_samples : int</span>
<span class="sd">            The number of indices to cut at. Defaults to 0, which</span>
<span class="sd">            means to sample at all indices.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments, passed directly to</span>
<span class="sd">            :meth:`pyknotid.spacecurves.openknot.OpenKnot.alexander_fractions`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>
        <span class="k">if</span> <span class="n">num_samples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="n">num_samples</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves.openknot</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpenKnot</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">points_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vprint</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">index = </span><span class="si">{}</span><span class="s1"> / </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)),</span>
                         <span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">other_index</span><span class="p">,</span> <span class="n">other_points_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="n">indices</span><span class="p">[(</span><span class="n">index</span><span class="o">+</span><span class="mi">2</span><span class="p">):]):</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">points_index</span><span class="p">:</span><span class="n">other_points_index</span><span class="p">],</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">alex</span> <span class="o">=</span> <span class="mf">1.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">alex</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">alexander_fractions</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">other_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">alex</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Knot.isolate_knot"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.isolate_knot">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">isolate_knot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Return indices of self.points within which the knot (if any)</span>
<span class="sd">        appears to lie, according to a simple closure algorithm.</span>

<span class="sd">        This method is experimental and may not provide very good results.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_isolated</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_isolated</span>
        <span class="n">determinant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determinant</span><span class="p">()</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpenKnot</span>

        <span class="n">k1</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">_isolate_open_knot</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">determinant</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k1</span><span class="p">))[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">k1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cached_isolated</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>

        <span class="n">roll_dist</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.25</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">roll_dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">_isolate_open_knot</span><span class="p">(</span><span class="n">k2</span><span class="p">,</span> <span class="n">determinant</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k2</span><span class="p">))[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;se&#39;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">-=</span> <span class="n">roll_dist</span>
        <span class="n">start</span> <span class="o">%=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">-=</span> <span class="n">roll_dist</span>
        <span class="n">end</span> <span class="o">%=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;now&#39;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_isolated</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span></div>

<div class="viewcode-block" id="Knot.plot_isolated"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.plot_isolated">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot_isolated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Plots the curve in red, except for the isolated local knot which</span>
<span class="sd">        is coloured blue. The local knot is found with self.isolate_knot,</span>
<span class="sd">        which may not be reliable or have good resolution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            kwargs are passed directly to :meth:`Knot.plot`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isolate_knot</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
            <span class="n">end</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>
        <span class="n">mus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
        <span class="n">mus</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.4</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mf">0.6</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="n">end</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
            <span class="n">mus</span> <span class="o">=</span> <span class="mf">0.4</span> <span class="o">-</span> <span class="n">mus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mus</span><span class="o">=</span><span class="n">mus</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">slip_triangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.representations</span><span class="w"> </span><span class="kn">import</span> <span class="n">Representation</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation</span><span class="p">()</span>

        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_crossings</span><span class="p">()</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">invs</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">new_r</span> <span class="o">=</span> <span class="n">Representation</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

                <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="n">new_cs</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="n">new_start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">new_end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">new_start</span> <span class="o">=</span> <span class="n">new_cs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">new_cs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_cs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="n">new_cs</span> <span class="o">=</span> <span class="n">new_cs</span><span class="p">[</span><span class="n">new_cs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new_cs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                    <span class="n">new_cs</span> <span class="o">=</span> <span class="n">new_cs</span><span class="p">[</span><span class="n">new_cs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new_cs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                    <span class="n">new_r</span><span class="o">.</span><span class="n">_remove_crossing</span><span class="p">(</span><span class="n">new_r</span><span class="o">.</span><span class="n">_gauss_code</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="n">new_end</span> <span class="o">=</span> <span class="n">new_cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">new_cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="n">new_cs</span> <span class="o">=</span> <span class="n">new_cs</span><span class="p">[</span><span class="n">new_cs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new_cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                    <span class="n">new_cs</span> <span class="o">=</span> <span class="n">new_cs</span><span class="p">[</span><span class="n">new_cs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new_cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                    <span class="n">new_r</span><span class="o">.</span><span class="n">_remove_crossing</span><span class="p">(</span><span class="n">new_r</span><span class="o">.</span><span class="n">_gauss_code</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

                <span class="n">new_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">new_start</span><span class="p">)):</span><span class="nb">int</span><span class="p">(</span><span class="n">new_end</span><span class="p">)]</span>
                <span class="n">new_start_remainder</span> <span class="o">=</span> <span class="n">new_start</span> <span class="o">%</span> <span class="mi">1</span>
                <span class="n">new_end_remainder</span> <span class="o">=</span> <span class="n">new_end</span> <span class="o">%</span> <span class="mi">1</span>

                <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">new_start</span><span class="p">)]</span> <span class="o">+</span> <span class="n">new_start_remainder</span> <span class="o">*</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">new_start</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">new_start</span><span class="p">)]),</span>
                                       <span class="n">new_points</span><span class="p">,</span>
                                       <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">new_end</span><span class="p">)]</span> <span class="o">+</span> <span class="n">new_end_remainder</span> <span class="o">*</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">new_end</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">new_end</span><span class="p">)])))</span>
                <span class="c1"># results[(i, j)] = points[int(new_start):int(new_end)]</span>
                <span class="n">results</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_points</span>
                <span class="n">invs</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">new_r</span><span class="p">)</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.gridspec</span><span class="w"> </span><span class="kn">import</span> <span class="n">GridSpec</span>

        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>
        <span class="n">mins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">maxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">span</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">maxs</span> <span class="o">-</span> <span class="n">mins</span><span class="p">)[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">span</span> <span class="o">*</span> <span class="mf">1.16</span>

        <span class="n">xmin</span> <span class="o">=</span> <span class="n">mins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.08</span><span class="o">*</span><span class="n">span</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.08</span><span class="o">*</span><span class="n">span</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">mins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.08</span><span class="o">*</span><span class="n">span</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.08</span><span class="o">*</span><span class="n">span</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">coords</span><span class="p">,</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;coords are&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>

            <span class="n">inv</span> <span class="o">=</span> <span class="n">invs</span><span class="p">[</span><span class="n">coords</span><span class="p">]</span>
            <span class="n">colour</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span> <span class="k">if</span> <span class="n">inv</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;green&#39;</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">colour</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

<div class="viewcode-block" id="Knot.whitney_index"><a class="viewcode-back" href="../../../sources/spacecurves/knot.html#pyknotid.spacecurves.knot.Knot.whitney_index">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">whitney_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;The degree of the Gauss map mapping a point on the curve to the</span>
<span class="sd">        direction of the positive tangent vector at this point.&#39;&#39;&#39;</span>

        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>
        <span class="n">tangents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangents</span><span class="p">()</span>

        <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tangents</span><span class="p">)</span>

        <span class="n">directions</span><span class="p">[</span><span class="n">directions</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">directions</span><span class="p">[</span><span class="n">directions</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="n">jumps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">directions</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">directions</span>


        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">jumps</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">jumps</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">index</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">arnold_2St_2Jplus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.invariants</span><span class="w"> </span><span class="kn">import</span> <span class="n">arnold_2St_2Jplus</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Do *not* simplify, as this is only a plane curve invariant</span>
        <span class="k">return</span> <span class="n">arnold_2St_2Jplus</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">arnold_2St_2Jminus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.invariants</span><span class="w"> </span><span class="kn">import</span> <span class="n">arnold_2St_2Jminus</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gauss_code</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Do *not* simplify, as this is only a plane curve invariant</span>
        <span class="k">return</span> <span class="n">arnold_2St_2Jminus</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">plot_secant_manifold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot_extrema</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
        <span class="c1"># from colorsys import hls_to_rgb</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">hsluv</span><span class="w"> </span><span class="kn">import</span> <span class="n">hsluv_to_rgb</span><span class="p">,</span> <span class="n">hpluv_to_rgb</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">erfinv</span>

        <span class="c1"># import pyknotid.hsluvcolormap  # causes hsluv to be registered</span>

        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>

        <span class="n">colours</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)))</span>

        <span class="n">thetas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">phis</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i2</span><span class="p">,</span> <span class="n">other_point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i1</span><span class="o">+</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">i2</span> <span class="o">+=</span> <span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">direction</span> <span class="o">=</span> <span class="n">other_point</span> <span class="o">-</span> <span class="n">point</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">mag</span><span class="p">(</span><span class="n">direction</span><span class="p">))</span>
                <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># colours[i2, i1] = hls_to_rgb((phi + np.pi) / (2*np.pi), erfinv((theta / np.pi) * 2 - 1.) / 4.4 + 0.5, 1)</span>
                <span class="n">colours</span><span class="p">[</span><span class="n">i2</span><span class="p">,</span> <span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hsluv_to_rgb</span><span class="p">((</span><span class="mi">360</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">65</span><span class="p">))</span><span class="c1"># * (erfinv((theta / np.pi) * 2 - 1.) / 4.4 + 0.5)))</span>

                <span class="n">colours</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">]</span> <span class="o">=</span>  <span class="n">hsluv_to_rgb</span><span class="p">((</span><span class="mi">360</span> <span class="o">*</span> <span class="p">((</span><span class="n">phi</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">65</span><span class="p">))</span>

                <span class="n">phis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
                <span class="n">thetas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="n">heights</span><span class="p">[</span><span class="n">i2</span><span class="p">,</span> <span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span>
                <span class="n">heights</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">theta</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">phis</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">phis</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">thetas</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">thetas</span><span class="p">))</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">colours</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># ax.contour(heights, cmap=&#39;Greys&#39;, levels=np.linspace(-1, 1, 13))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">heights</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Greys_r&#39;</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span>
                   <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">crossings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_crossings</span><span class="p">()</span>

        <span class="c1"># Plot the lines between crossings</span>
        <span class="n">unique_crossings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">crossings_done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">crossing</span> <span class="ow">in</span> <span class="n">crossings</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">crossing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">crossings_done</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">crossings_done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">crossing</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">unique_crossings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">crossing</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">crossing</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_crossings</span><span class="p">):</span>
            <span class="n">start1</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">height1</span><span class="p">,</span> <span class="n">sign1</span> <span class="o">=</span> <span class="n">crossing</span>
            <span class="k">for</span> <span class="n">other_crossing</span> <span class="ow">in</span> <span class="n">unique_crossings</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">start2</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">height2</span><span class="p">,</span> <span class="n">sign2</span> <span class="o">=</span> <span class="n">other_crossing</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">start2</span> <span class="o">&gt;</span> <span class="n">start1</span> <span class="ow">and</span> <span class="n">end1</span> <span class="o">&gt;</span> <span class="n">start2</span> <span class="ow">and</span> <span class="n">end2</span> <span class="o">&gt;</span> <span class="n">end1</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">colour</span> <span class="o">=</span> <span class="s1">&#39;crimson&#39;</span> <span class="k">if</span> <span class="n">sign1</span> <span class="o">*</span> <span class="n">sign2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;lime&#39;</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">start1</span><span class="p">,</span> <span class="n">start2</span><span class="p">],</span> <span class="p">[</span><span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">colour</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Plot the crossing points</span>
        <span class="k">for</span> <span class="n">crossing</span> <span class="ow">in</span> <span class="n">crossings</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">crossing</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">crossing</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">colour</span> <span class="o">=</span> <span class="s1">&#39;crimson&#39;</span> <span class="k">if</span> <span class="n">crossing</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;lime&#39;</span>
                <span class="n">edge_colour</span> <span class="o">=</span> <span class="s1">&#39;white&#39;</span> <span class="k">if</span> <span class="n">crossing</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;black&#39;</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">crossing</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">crossing</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="n">colour</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="n">edge_colour</span><span class="p">,</span>
                           <span class="n">s</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Plot extrema of the planar projection</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">maxima_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">zs</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">zs</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">minima_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">zs</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">zs</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;maxima indices&#39;</span><span class="p">,</span> <span class="n">maxima_indices</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;minima indices&#39;</span><span class="p">,</span> <span class="n">minima_indices</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">maximum</span> <span class="ow">in</span> <span class="n">maxima_indices</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">maximum</span><span class="p">],</span> <span class="p">[</span><span class="n">maximum</span><span class="p">],</span>  <span class="n">color</span><span class="o">=</span><span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;pink&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">minimum</span> <span class="ow">in</span> <span class="n">minima_indices</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">minimum</span><span class="p">],</span> <span class="p">[</span><span class="n">minimum</span><span class="p">],</span>  <span class="n">color</span><span class="o">=</span><span class="s1">&#39;cyan&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;pink&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>


        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        
        <span class="c1"># Plot the knot projection inset</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">mpl_toolkits.axes_grid1.inset_locator</span><span class="w"> </span><span class="kn">import</span> <span class="n">inset_axes</span>
        <span class="n">inset_ax</span> <span class="o">=</span> <span class="n">inset_axes</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="s2">&quot;45%&quot;</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="s2">&quot;45%&quot;</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1"># inset_ax = fig.add_axes([0.6, 0.1, 0.4, 0.4])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_projection</span><span class="p">(</span><span class="n">fig_ax</span><span class="o">=</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">inset_ax</span><span class="p">))</span>
        <span class="c1"># inset_ax.set_axis_off()</span>
        <span class="n">inset_ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">inset_ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">inset_ax</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;i2&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;i1&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">plot_secant_crossings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        <span class="n">crossings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_crossings</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">radii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">radii</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

        <span class="n">unique_crossings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">crossings_done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">crossing</span> <span class="ow">in</span> <span class="n">crossings</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">crossing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">crossings_done</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">crossings_done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">crossing</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">unique_crossings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">crossing</span><span class="p">)</span>

        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">crossing</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_crossings</span><span class="p">):</span>
            <span class="n">start1</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">height1</span><span class="p">,</span> <span class="n">sign1</span> <span class="o">=</span> <span class="n">crossing</span>
            <span class="k">for</span> <span class="n">other_crossing</span> <span class="ow">in</span> <span class="n">unique_crossings</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">start2</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">height2</span><span class="p">,</span> <span class="n">sign2</span> <span class="o">=</span> <span class="n">other_crossing</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">start2</span> <span class="o">&gt;</span> <span class="n">start1</span> <span class="ow">and</span> <span class="n">end1</span> <span class="o">&gt;</span> <span class="n">start2</span> <span class="ow">and</span> <span class="n">end2</span> <span class="o">&gt;</span> <span class="n">end1</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">start_point1</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">start1</span><span class="p">)]</span>
                <span class="n">start_point1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">start1</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">start1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">start1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">start1</span><span class="p">)])</span>
                <span class="n">segment_point1s</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">start1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">start2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">end_point1</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">start2</span><span class="p">)]</span>
                <span class="n">end_point1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">start2</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">start2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">start2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">start2</span><span class="p">)])</span>

                <span class="n">segment1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">start_point1</span><span class="p">,</span> <span class="n">segment_point1s</span><span class="p">,</span> <span class="n">end_point1</span><span class="p">])</span>

                <span class="c1">#</span>
                <span class="n">start_point2</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">end1</span><span class="p">)]</span>
                <span class="n">start_point2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">end1</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">end1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">end1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">end1</span><span class="p">)])</span>
                <span class="n">segment_point2s</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">end1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">end2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">end_point2</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">end2</span><span class="p">)]</span>
                <span class="n">end_point2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">end2</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">end2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">end2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">end2</span><span class="p">)])</span>

                <span class="n">segment2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">start_point2</span><span class="p">,</span> <span class="n">segment_point2s</span><span class="p">,</span> <span class="n">end_point2</span><span class="p">])</span>

                <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>
                    <span class="n">start_point1</span> <span class="o">-</span> <span class="n">segment2</span><span class="p">,</span>
                    <span class="n">segment1</span> <span class="o">-</span> <span class="n">end_point2</span><span class="p">])</span>

                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">directions</span><span class="p">)</span>

        <span class="n">sphere_lines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
            <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">line</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">line</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">radii</span><span class="p">)</span>
            <span class="n">phis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">line</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">line</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

            <span class="n">local_radius</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">-</span> <span class="mf">0.02</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">radius</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetas</span><span class="p">))</span>

            <span class="n">sphere_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">sphere_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetas</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phis</span><span class="p">)</span>
            <span class="n">sphere_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetas</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phis</span><span class="p">)</span>
            <span class="n">sphere_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetas</span><span class="p">)</span>

            <span class="c1"># sphere_points += 2*(np.random.random(sphere_points.shape) - 0.5) * 0.005 * radius</span>

            <span class="n">sphere_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sphere_points</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tube_radius</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Plot the poles</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">vispy.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_sphere</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">vispy.scene</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mesh</span>
        <span class="n">meshdata</span> <span class="o">=</span> <span class="n">create_sphere</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="mf">0.035</span> <span class="o">*</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">meshdata</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="n">meshdata</span><span class="o">.</span><span class="n">get_faces</span><span class="p">()</span>
        <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">radius</span>
        <span class="n">mesh1</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="n">faces</span><span class="p">,</span> <span class="n">vertex_colors</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]))</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">radius</span>
        <span class="n">mesh2</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="n">faces</span><span class="p">,</span> <span class="n">vertex_colors</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]))</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">pyknotid.visualise</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pvis</span>
        <span class="n">pvis</span><span class="o">.</span><span class="n">vispy_canvas</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mesh1</span><span class="p">)</span>
        <span class="n">pvis</span><span class="o">.</span><span class="n">vispy_canvas</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mesh2</span><span class="p">)</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">colorsys</span><span class="w"> </span><span class="kn">import</span> <span class="n">hsv_to_rgb</span>
        <span class="n">colours</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsv_to_rgb</span><span class="p">(</span><span class="n">hue</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span> <span class="k">for</span> <span class="n">hue</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sphere_lines</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">colours</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">colours</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">colours</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span><span class="p">,</span> <span class="n">colour</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sphere_lines</span><span class="p">,</span> <span class="n">colours</span><span class="p">):</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves.openknot</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpenKnot</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">k</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">clf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tube_radius</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="n">colour</span><span class="p">,</span> <span class="n">zero_centroid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">mag</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_isolate_open_knot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.spacecurves</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpenKnot</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>  
        <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">alexanders</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">alexander_fractions</span><span class="p">()</span>
    <span class="n">main_det</span><span class="p">,</span> <span class="n">main_frac</span> <span class="o">=</span> <span class="n">alexanders</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


    <span class="k">if</span> <span class="n">main_det</span> <span class="o">!=</span> <span class="n">det</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">half_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">points</span><span class="p">[:</span><span class="n">half_len</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">k1_knotted</span><span class="p">,</span> <span class="n">k1_start</span><span class="p">,</span> <span class="n">k1_end</span> <span class="o">=</span> <span class="n">_isolate_open_knot</span><span class="p">(</span>
        <span class="n">k1</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">half_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k1_knotted</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">k1_start</span><span class="p">,</span> <span class="n">k1_end</span><span class="p">)</span>

    <span class="n">k2</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">half_len</span><span class="p">:],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">k2_knotted</span><span class="p">,</span> <span class="n">k2_start</span><span class="p">,</span> <span class="n">k2_end</span> <span class="o">=</span> <span class="n">_isolate_open_knot</span><span class="p">(</span>
        <span class="n">k2</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">half_len</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k2_knotted</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">k2_start</span><span class="p">,</span> <span class="n">k2_end</span><span class="p">)</span>

    <span class="n">quarter_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">//</span> <span class="mi">4</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">quarter_len</span><span class="p">:(</span><span class="n">quarter_len</span> <span class="o">+</span> <span class="n">half_len</span><span class="p">)],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">k3_knotted</span><span class="p">,</span> <span class="n">k3_start</span><span class="p">,</span> <span class="n">k3_end</span> <span class="o">=</span> <span class="n">_isolate_open_knot</span><span class="p">(</span>
        <span class="n">k3</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">quarter_len</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">quarter_len</span> <span class="o">+</span> <span class="n">half_len</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k3_knotted</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">k3_start</span><span class="p">,</span> <span class="n">k3_end</span><span class="p">)</span>

    <span class="n">k4</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">quarter_len</span><span class="p">:],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">k4_knotted</span><span class="p">,</span> <span class="n">k4_start</span><span class="p">,</span> <span class="n">k4_end</span> <span class="o">=</span> <span class="n">_isolate_open_knot</span><span class="p">(</span>
        <span class="n">k4</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">quarter_len</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k4_knotted</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">k4_start</span><span class="p">,</span> <span class="n">k4_end</span><span class="p">)</span>

    <span class="n">k5</span> <span class="o">=</span> <span class="n">OpenKnot</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">points</span><span class="p">[:</span><span class="o">-</span><span class="n">quarter_len</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">k5_knotted</span><span class="p">,</span> <span class="n">k5_start</span><span class="p">,</span> <span class="n">k5_end</span> <span class="o">=</span> <span class="n">_isolate_open_knot</span><span class="p">(</span>
        <span class="n">k5</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">quarter_len</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k5_knotted</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">k5_start</span><span class="p">,</span> <span class="n">k5_end</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2014-2018.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>