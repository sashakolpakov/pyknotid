

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyknotid.representations.planardiagram &mdash; pyknotid 0.5.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=c3dca1ed"></script>
      <script src="../../../_static/doctools.js?v=888ff710"></script>
      <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            pyknotid
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/spacecurves/index.html">Space curve analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html">Invariants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.alexander"><code class="docutils literal notranslate"><span class="pre">alexander()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.alexander_cypari"><code class="docutils literal notranslate"><span class="pre">alexander_cypari()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.alexander_mathematica"><code class="docutils literal notranslate"><span class="pre">alexander_mathematica()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.alexander_maxima"><code class="docutils literal notranslate"><span class="pre">alexander_maxima()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.arnold_2St_2Jminus"><code class="docutils literal notranslate"><span class="pre">arnold_2St_2Jminus()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.arnold_2St_2Jplus"><code class="docutils literal notranslate"><span class="pre">arnold_2St_2Jplus()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.contract_points"><code class="docutils literal notranslate"><span class="pre">contract_points()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.hyperbolic_volume"><code class="docutils literal notranslate"><span class="pre">hyperbolic_volume()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.jones_mathematica"><code class="docutils literal notranslate"><span class="pre">jones_mathematica()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.second_order_writhe"><code class="docutils literal notranslate"><span class="pre">second_order_writhe()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.self_linking"><code class="docutils literal notranslate"><span class="pre">self_linking()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.vassiliev_degree_2"><code class="docutils literal notranslate"><span class="pre">vassiliev_degree_2()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.vassiliev_degree_3"><code class="docutils literal notranslate"><span class="pre">vassiliev_degree_3()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/invariants.html#pyknotid.invariants.virtual_vassiliev_degree_3"><code class="docutils literal notranslate"><span class="pre">virtual_vassiliev_degree_3()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/representations/index.html">Topological representations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/catalogue/index.html">Knot catalogue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html">Visualise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_line"><code class="docutils literal notranslate"><span class="pre">plot_line()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_projection"><code class="docutils literal notranslate"><span class="pre">plot_projection()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_shell_vispy"><code class="docutils literal notranslate"><span class="pre">plot_shell_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_sphere_lambert_sharp_vispy"><code class="docutils literal notranslate"><span class="pre">plot_sphere_lambert_sharp_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_sphere_lambert_vispy"><code class="docutils literal notranslate"><span class="pre">plot_sphere_lambert_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_sphere_mollweide_vispy"><code class="docutils literal notranslate"><span class="pre">plot_sphere_mollweide_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/visualise.html#pyknotid.visualise.plot_sphere_shell_vispy"><code class="docutils literal notranslate"><span class="pre">plot_sphere_shell_vispy()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sources/about.html">About pyknotid</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pyknotid</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyknotid.representations.planardiagram</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyknotid.representations.planardiagram</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">PlanarDiagram</span>
<span class="sd">=============</span>

<span class="sd">Classes for working with planar diagram notation of knot diagrams.</span>

<span class="sd">See individual class documentation for more details.</span>

<span class="sd">API documentation</span>
<span class="sd">~~~~~~~~~~~~~~~~~</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>


<div class="viewcode-block" id="PlanarDiagram"><a class="viewcode-back" href="../../../sources/representations/planardiagram.html#pyknotid.representations.planardiagram.PlanarDiagram">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">PlanarDiagram</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A class for containing and manipulating planar diagrams.</span>

<span class="sd">    Just provides convenient display and conversion methods for now.</span>
<span class="sd">    In the future, will support simplification.</span>

<span class="sd">    Shorthand input may be of the form ``X_1,4,2,5 X_3,6,4,1 X_5,2,6,3``.</span>
<span class="sd">    This is (should be?) the same as returned by repr.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    crossings : array-like or string or GaussCode</span>
<span class="sd">        The list of crossings in the diagram, which will be converted</span>
<span class="sd">        to an internal planar diagram representation. Currently these are</span>
<span class="sd">        mostly converted via a GaussCode instance, so in addition to the</span>
<span class="sd">        shorthand any array-like supported by</span>
<span class="sd">        :class:`~pyknotid.representations.gausscode.GaussCode` may be used.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crossings</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pyknotid.representations</span><span class="w"> </span><span class="kn">import</span> <span class="n">gausscode</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crossings</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shorthand_to_crossings</span><span class="p">(</span><span class="n">crossings</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crossings</span><span class="p">,</span> <span class="n">gausscode</span><span class="o">.</span><span class="n">GaussCode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">gausscode_to_crossings</span><span class="p">(</span><span class="n">crossings</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">gausscode_to_crossings</span><span class="p">(</span>
                <span class="n">gausscode</span><span class="o">.</span><span class="n">GaussCode</span><span class="p">(</span><span class="n">crossings</span><span class="p">)))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lenstr</span> <span class="o">=</span> <span class="s1">&#39;PD with </span><span class="si">{0}</span><span class="s1">: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">lenstr</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">crossing</span><span class="p">)</span> <span class="k">for</span> <span class="n">crossing</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

<div class="viewcode-block" id="PlanarDiagram.as_mathematica"><a class="viewcode-back" href="../../../sources/representations/planardiagram.html#pyknotid.representations.planardiagram.PlanarDiagram.as_mathematica">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">as_mathematica</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a mathematica code representation of self, usable in the</span>
<span class="sd">        mathematica knot tools.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;PD[&#39;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">crossing</span><span class="o">.</span><span class="n">as_mathematica</span><span class="p">()</span> <span class="k">for</span> <span class="n">crossing</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span></div>

<div class="viewcode-block" id="PlanarDiagram.as_spherogram"><a class="viewcode-back" href="../../../sources/representations/planardiagram.html#pyknotid.representations.planardiagram.PlanarDiagram.as_spherogram">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">as_spherogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get a planar diagram class from the Spherogram module, which</span>
<span class="sd">        can be used to access SnapPy&#39;s manifold tools.</span>

<span class="sd">        This method requires that spherogram and SnapPy are installed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">spherogram</span><span class="w"> </span><span class="kn">import</span> <span class="n">Crossing</span><span class="p">,</span> <span class="n">Link</span>
        <span class="n">scs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Crossing</span><span class="p">()</span> <span class="k">for</span> <span class="n">crossing</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
                <span class="n">number</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">number</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                    <span class="n">otheri</span><span class="p">,</span> <span class="n">otherj</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
                    <span class="n">scs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">scs</span><span class="p">[</span><span class="n">otheri</span><span class="p">][</span><span class="n">otherj</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">indices</span><span class="p">[</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">scs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlanarDiagram.as_networkx_extended"><a class="viewcode-back" href="../../../sources/representations/planardiagram.html#pyknotid.representations.planardiagram.PlanarDiagram.as_networkx_extended">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">as_networkx_extended</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;(internal use only) Returns a networkx Graph along with extra</span>
<span class="sd">        information about the crossings.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># print(&#39;pd is&#39;, self)</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">edge_directions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
        <span class="n">intermediate_edges_by_node</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
        <span class="n">intermediate_node_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node_index</span><span class="p">,</span> <span class="n">crossing</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">crossing_index</span><span class="p">,</span> <span class="n">arc_number</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">crossing</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">arc_number</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                    <span class="n">other_node_index</span><span class="p">,</span> <span class="n">other_height</span><span class="p">,</span> <span class="n">other_crossing_index</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">arc_number</span><span class="p">]</span>
                    <span class="c1"># edges.append([other_node_index, node_index])</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">other_node_index</span><span class="p">,</span> <span class="n">intermediate_node_index</span><span class="p">])</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">node_index</span><span class="p">,</span> <span class="n">intermediate_node_index</span><span class="p">])</span>

                    <span class="n">height</span> <span class="o">=</span> <span class="n">index_height</span><span class="p">(</span><span class="n">crossing_index</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">crossing</span><span class="o">.</span><span class="n">is_outgoing</span><span class="p">(</span><span class="n">arc_number</span><span class="p">):</span>
                        <span class="c1"># heights[node_index, other_node_index, arc_number] = (height, other_height)</span>
                        <span class="n">heights</span><span class="p">[</span><span class="n">node_index</span><span class="p">,</span> <span class="n">intermediate_node_index</span><span class="p">,</span> <span class="n">arc_number</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
                        <span class="n">heights</span><span class="p">[</span><span class="n">intermediate_node_index</span><span class="p">,</span> <span class="n">other_node_index</span><span class="p">,</span> <span class="n">arc_number</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">other_height</span><span class="p">)</span>

                        <span class="c1"># edge_directions.append((node_index, other_node_index, arc_number))</span>
                        <span class="n">edge_directions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node_index</span><span class="p">,</span> <span class="n">intermediate_node_index</span><span class="p">,</span> <span class="n">arc_number</span><span class="p">))</span>
                        <span class="n">edge_directions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">intermediate_node_index</span><span class="p">,</span> <span class="n">other_node_index</span><span class="p">,</span> <span class="n">arc_number</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># heights[other_node_index, node_index, arc_number] = (other_height, height)</span>
                        <span class="n">heights</span><span class="p">[</span><span class="n">other_node_index</span><span class="p">,</span> <span class="n">intermediate_node_index</span><span class="p">,</span> <span class="n">arc_number</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">other_height</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
                        <span class="n">heights</span><span class="p">[</span><span class="n">intermediate_node_index</span><span class="p">,</span> <span class="n">node_index</span><span class="p">,</span> <span class="n">arc_number</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

                        <span class="c1"># edge_directions.append((other_node_index, node_index, arc_number))</span>
                        <span class="n">edge_directions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">other_node_index</span><span class="p">,</span> <span class="n">intermediate_node_index</span><span class="p">,</span> <span class="n">arc_number</span><span class="p">))</span>
                        <span class="n">edge_directions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">intermediate_node_index</span><span class="p">,</span> <span class="n">node_index</span><span class="p">,</span> <span class="n">arc_number</span><span class="p">))</span>

                    <span class="n">intermediate_edges_by_node</span><span class="p">[</span><span class="n">node_index</span><span class="p">][</span><span class="n">crossing_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">intermediate_node_index</span>
                    <span class="n">intermediate_edges_by_node</span><span class="p">[</span><span class="n">other_node_index</span><span class="p">][</span><span class="n">other_crossing_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">intermediate_node_index</span>

                    <span class="n">intermediate_node_index</span> <span class="o">+=</span> <span class="mi">1</span> 
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">arc_number</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_index</span><span class="p">,</span> <span class="n">index_height</span><span class="p">(</span><span class="n">crossing_index</span><span class="p">),</span> <span class="n">crossing_index</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">intermediate_nodes</span> <span class="ow">in</span> <span class="n">intermediate_edges_by_node</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">intermediate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">intermediate_nodes</span><span class="p">):</span>
                <span class="n">next_intermediate</span> <span class="o">=</span> <span class="n">intermediate_nodes</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">intermediate</span><span class="p">,</span> <span class="n">next_intermediate</span><span class="p">])</span>

        <span class="c1"># print(&#39;intermediates are&#39;, intermediate_edges_by_node)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

        <span class="c1"># print(&#39;possible heights:&#39;)</span>
        <span class="c1"># for key, value in sorted(heights.items()):</span>
        <span class="c1">#     print(key, value)</span>


        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">duplicates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">duplicates</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">edge_directions</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="PlanarDiagram.as_networkx"><a class="viewcode-back" href="../../../sources/representations/planardiagram.html#pyknotid.representations.planardiagram.PlanarDiagram.as_networkx">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">as_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Get a networkx graph representing the planar diagram, where</span>
<span class="sd">        each node is a crossing and each edge is an arc. This is a</span>
<span class="sd">        non-directed non-multi graph; where two arcs join the same crossing,</span>
<span class="sd">        they are represented as a single edge, but information about</span>
<span class="sd">        duplicates is returned alongside the graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        g : Graph</span>
<span class="sd">            The networkx graph</span>
<span class="sd">        duplicates : list</span>
<span class="sd">            A list of tuples representing nodes joined by multiple edges.</span>
<span class="sd">        heights : dict</span>
<span class="sd">            A dictionary of (start, end, arc_number) graph edges,</span>
<span class="sd">            containing the start and end height of each edge.</span>
<span class="sd">        first_edge : tuple</span>
<span class="sd">            The first edge in the graph, including (start, end, arc_number).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># print(&#39;pd is&#39;, self)</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">edge_directions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node_index</span><span class="p">,</span> <span class="n">crossing</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">crossing_index</span><span class="p">,</span> <span class="n">arc_number</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">crossing</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">arc_number</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                    <span class="n">other_node_index</span><span class="p">,</span> <span class="n">other_height</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">arc_number</span><span class="p">]</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">other_node_index</span><span class="p">,</span> <span class="n">node_index</span><span class="p">])</span>

                    <span class="n">height</span> <span class="o">=</span> <span class="n">index_height</span><span class="p">(</span><span class="n">crossing_index</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">crossing</span><span class="o">.</span><span class="n">is_outgoing</span><span class="p">(</span><span class="n">arc_number</span><span class="p">):</span>
                        <span class="c1"># print(&#39;node {} {}, crossing {} is outgoing to {}&#39;.format(</span>
                        <span class="c1">#     node_index, crossing, arc_number, other_node_index))</span>
                        <span class="n">heights</span><span class="p">[</span><span class="n">node_index</span><span class="p">,</span> <span class="n">other_node_index</span><span class="p">,</span> <span class="n">arc_number</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">other_height</span><span class="p">)</span>
                        <span class="n">edge_directions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node_index</span><span class="p">,</span> <span class="n">other_node_index</span><span class="p">,</span> <span class="n">arc_number</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># print(&#39;node {} {}, crossing {} is incoming from {}&#39;.format(</span>
                            <span class="c1"># node_index, crossing, arc_number, other_node_index))</span>
                        <span class="n">heights</span><span class="p">[</span><span class="n">other_node_index</span><span class="p">,</span> <span class="n">node_index</span><span class="p">,</span> <span class="n">arc_number</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">other_height</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
                        <span class="n">edge_directions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">other_node_index</span><span class="p">,</span> <span class="n">node_index</span><span class="p">,</span> <span class="n">arc_number</span><span class="p">))</span>
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">arc_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_index</span><span class="p">,</span> <span class="n">index_height</span><span class="p">(</span><span class="n">crossing_index</span><span class="p">)</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

        <span class="c1"># print(&#39;possible heights:&#39;)</span>
        <span class="c1"># for key, value in sorted(heights.items()):</span>
        <span class="c1">#     print(key, value)</span>


        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">duplicates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">duplicates</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">edge_directions</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div></div>
            
<div class="viewcode-block" id="index_height"><a class="viewcode-back" href="../../../sources/representations/planardiagram.html#pyknotid.representations.planardiagram.index_height">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">index_height</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Returns the height based on the index of the crossing in an entry</span>
<span class="sd">    of a planar diagram; the 0th and 2nd indices are under crossings,</span>
<span class="sd">    and the 1st and 3rd are over crossings.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.</span>
    <span class="k">return</span> <span class="mf">1.</span></div>

<div class="viewcode-block" id="Crossing"><a class="viewcode-back" href="../../../sources/representations/planardiagram.html#pyknotid.representations.planardiagram.Crossing">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">Crossing</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A single crossing in a planar diagram. Each :class:`PlanarDiagram`</span>
<span class="sd">    is a list of these.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : int or None</span>
<span class="sd">        The first entry in the list of lines meeting at this Crossing.</span>
<span class="sd">    b : int or None</span>
<span class="sd">        The second entry in the list of lines meeting at this Crossing.</span>
<span class="sd">    c : int or None</span>
<span class="sd">        The third entry in the list of lines meeting at this Crossing.</span>
<span class="sd">    d : int or None</span>
<span class="sd">        The fourth entry in the list of lines meeting at this Crossing.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Crossing</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>

<div class="viewcode-block" id="Crossing.valid"><a class="viewcode-back" href="../../../sources/representations/planardiagram.html#pyknotid.representations.planardiagram.Crossing.valid">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        True if all intersecting lines are not None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Crossing.components"><a class="viewcode-back" href="../../../sources/representations/planardiagram.html#pyknotid.representations.planardiagram.Crossing.components">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a de-duplicated list of lines intersecting at this Crossing.</span>

<span class="sd">        :rtype: list</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;X_{{</span><span class="si">{0}</span><span class="s1">,</span><span class="si">{1}</span><span class="s1">,</span><span class="si">{2}</span><span class="s1">,</span><span class="si">{3}</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

<div class="viewcode-block" id="Crossing.as_mathematica"><a class="viewcode-back" href="../../../sources/representations/planardiagram.html#pyknotid.representations.planardiagram.Crossing.as_mathematica">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">as_mathematica</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get a string of mathematica code that can represent the Crossing</span>
<span class="sd">        in mathematica&#39;s knot library.</span>

<span class="sd">        The mathematica code won&#39;t be valid if any lines of self are None.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="s1">&#39;X[</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span></div>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>

<div class="viewcode-block" id="Crossing.update_line_number"><a class="viewcode-back" href="../../../sources/representations/planardiagram.html#pyknotid.representations.planardiagram.Crossing.update_line_number">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">update_line_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Replaces all instances of the given line number in self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        old : int</span>
<span class="sd">            The old line number</span>
<span class="sd">        new : int</span>
<span class="sd">            The number to replace it with</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">old</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_incoming</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;arc index doesn</span><span class="se">\&#39;</span><span class="s1">t intersect crossing&#39;</span><span class="p">)</span>
        <span class="n">other_index</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">other_index</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># =&gt; index is the final arc</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">other_index</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># =&gt; other_index is the final arc</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">other_index</span> <span class="o">&gt;</span> <span class="n">index</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_outgoing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_incoming</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="shorthand_to_crossings"><a class="viewcode-back" href="../../../sources/representations/planardiagram.html#pyknotid.representations.planardiagram.shorthand_to_crossings">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">shorthand_to_crossings</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Takes a planar diagram shorthand string, and returns a list of</span>
<span class="sd">    :class:`Crossing` objects.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">crossings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">:</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span>
            <span class="n">crossings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Crossing</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span>
            <span class="n">crossings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">crossings</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">gausscode_to_crossings</span><span class="p">(</span><span class="n">gc</span><span class="p">):</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">_gauss_code</span>
    <span class="n">crossings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">incomplete_crossings</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">line_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">cl</span><span class="p">]</span>
    <span class="n">total_lines</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">line_lengths</span><span class="p">)</span>
    <span class="n">line_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">line_lengths</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">curline</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cl</span><span class="p">):</span>
        <span class="n">curline</span> <span class="o">=</span> <span class="n">line_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">over</span><span class="p">,</span> <span class="n">clockwise</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">incomplete_crossings</span><span class="p">:</span>
                <span class="n">crossing</span> <span class="o">=</span> <span class="n">incomplete_crossings</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">crossing</span> <span class="o">=</span> <span class="n">Crossing</span><span class="p">()</span>

            <span class="n">inline</span> <span class="o">=</span> <span class="n">curline</span>
            <span class="n">curline</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">curline</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">line_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">line_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">curline</span> <span class="o">=</span> <span class="n">line_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">outline</span> <span class="o">=</span> <span class="n">curline</span>

            <span class="k">if</span> <span class="n">over</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">crossing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inline</span>
                <span class="n">crossing</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">outline</span>
                <span class="n">crossings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">crossing</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">clockwise</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">crossing</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">inline</span>
                    <span class="n">crossing</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">outline</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">crossing</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">inline</span>
                    <span class="n">crossing</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">outline</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">crossing</span><span class="o">.</span><span class="n">valid</span><span class="p">():</span>
                <span class="n">incomplete_crossings</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">crossing</span>

    <span class="k">return</span> <span class="n">crossings</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2014-2018.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>